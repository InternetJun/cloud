Index: common/core/src/main/java/org/example/common/core/leetcode/abTest/Test.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/abTest/Test.java b/common/core/src/main/java/org/example/common/core/leetcode/abTest/Test.java
new file mode 100644
--- /dev/null	(date 1698633783355)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/abTest/Test.java	(date 1698633783355)
@@ -0,0 +1,11 @@
+package org.example.common.core.leetcode.abTest;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/18 15:20
+ */
+public abstract class Test {
+    abstract void method();
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/string/Longest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/string/Longest.java b/common/core/src/main/java/org/example/common/core/leetcode/string/Longest.java
new file mode 100644
--- /dev/null	(date 1698633783447)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/string/Longest.java	(date 1698633783447)
@@ -0,0 +1,408 @@
+package org.example.common.core.leetcode.string;
+
+import lombok.extern.slf4j.Slf4j;
+import org.junit.Test;
+
+import java.util.*;
+import java.util.stream.Collectors;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/8/24 11:01
+ */
+@Slf4j
+public class Longest {
+    /**
+     * 最长的字串
+     * 注意是字串。不是序列。
+     * 所以要用双指针的写法。
+     * 用框架！！
+     *
+     * @param s
+     * @return
+     */
+    public int lengthOfLongestSubString(String s) {
+        Map<Character, Integer> windows = new HashMap<>();
+        int left = 0, right = 0;
+        while (right < s.length()) {
+            char c = s.charAt(right);
+            windows.put(c, windows.getOrDefault(c, 0) + 1);
+            // 加大
+            right++;
+            // 进行更新数据。
+            System.out.printf("window: [%d, %d)\n", left, right);
+            // 判断要不要收缩
+//            while (left < right && windows need shrink) {
+//                char d = s.charAt(left);
+//                windows.put(d, windows.get(d) -1 );
+//                left++;
+            // 进行更新
+//            }
+        }
+        return windows.keySet().size();
+    }
+
+
+    public int lengthOfLongestSubStringSolution(String s) {
+        Map<Character, Integer> windows = new HashMap<>();
+        int left = 0, right = 0;
+        int res = 0;
+        while (right < s.length()) {
+            char c = s.charAt(right);
+            right++;
+            windows.put(c, windows.getOrDefault(c, 0) + 1);
+            while (windows.get(c) > 1) {
+                char d = s.charAt(left);
+                left++;
+                windows.put(d, windows.get(d) - 1);
+            }
+            res = Math.max(res, right - left);
+        }
+        return res;
+    }
+
+    /**
+     * 最小
+     *
+     * @param s
+     * @param t
+     * @return
+     */
+    public String minWindow1001(String s, String t) {
+        String res = "";
+        Map<Character, Integer> need = new HashMap<>();
+        Map<Character, Integer> windows = new HashMap<>();
+        for (char c : t.toCharArray()) {
+            need.put(c, need.getOrDefault(c, 0) + 1);
+        }
+        int left = 0, right = 0, len = Integer.MAX_VALUE, start = 0;
+        int valid = 0;
+        // 左右指针的移动。
+        while (right < s.length()) {
+            char c = s.charAt(right);
+            right++;
+            if (windows.containsKey(c)) {
+                windows.put(c, windows.getOrDefault(c,0) + 1);
+                if (windows.get(c).equals(need.get(c))) {
+                    valid++;
+                }
+            }
+
+            while (valid == need.size()) {
+                if (right - left < len) {
+                    start = left;
+                    len = right - left;
+                }
+                char d = s.charAt(left);
+                left++;
+                if (need.containsKey(d)) {
+                    if (windows.get(d).equals(need.get(d))) {
+                        valid--;
+                    }
+                    windows.put(d, windows.get(d) - 1);
+                }
+            }
+
+        }
+        return len == Integer.MAX_VALUE ? "" : s.substring(start, start + len);
+    }
+
+    LinkedList<String> track = new LinkedList<>();
+    /** 93. 复原 IP 地址
+     * https://leetcode.cn/problems/restore-ip-addresses/description/
+     *<p>
+     *     "0.011.255.245"
+     *</p>
+     *
+     * @param s
+     * @return
+     */
+    public List<String> restoreIpAddressesMe(String s) {
+        List<String> list = new ArrayList<>();
+        dfs(0, s, list);
+        return list;
+    }
+
+    public void dfs(int start, String s, List<String> list) {
+        if (track.size() == 4 && start == s.length()) {
+            list.add(String.join(".", track));
+            return;
+        }
+
+        for (int i = start; i < s.length(); i++) {
+            if (!isValid(s, start, i)) {
+                // 进入下一个循环
+                continue;
+            }
+            if (track.size() >= 4) {
+                // 退出；
+                break;
+            }
+            track.addLast(s.substring(start, i+1));
+            dfs(i+1, s, list);
+            track.removeLast();
+        }
+    }
+
+    @Test
+    public void testIp() {
+        System.out.println(restoreIpAddressesMe("101023"));
+    }
+
+    boolean isValid(String s, int start, int end) {
+        int length = end - start + 1;
+
+        if (length == 0 || length > 3) {
+            return false;
+        }
+
+        if (length == 1) {
+            // 如果只有一位数字，肯定是合法的
+            return true;
+        }
+
+        if (s.charAt(start) == '0') {
+            // 多于一位数字，但开头是 0，肯定不合法
+            return false;
+        }
+
+        if (length <= 2) {
+            // 排除了开头是 0 的情况，那么如果是两位数，怎么着都是合法的
+            return true;
+        }
+
+        // 现在输入的一定是三位数
+        if (Integer.parseInt(s.substring(start, start + length)) > 255) {
+            // 不可能大于 255
+            return false;
+        } else {
+            return true;
+        }
+
+    }
+
+    List<String> res = new LinkedList<>();
+
+    public List<String> restoreIpAddresses(String s) {
+        backtrack(s, 0);
+        return res;
+    }
+
+    // 回溯算法框架
+    void backtrack(String s, int start) {
+        if (start == s.length() && track.size() == 4) {
+            // base case，走到叶子节点
+            // 即整个 s 被成功分割为合法的四部分，记下答案
+            res.add(String.join(".", track));
+        }
+        for (int i = start; i < s.length(); i++) {
+            if (!isValid(s, start, i)) {
+                // s[start..i] 不是合法的 ip 数字，不能分割
+                continue;
+            }
+            if (track.size() >= 4) {
+                // 已经分解成 4 部分了，不能再分解了
+                break;
+            }
+            // s[start..i] 是一个合法的 ip 数字，可以进行分割
+            // 做选择，把 s[start..i] 放入路径列表中
+            track.addLast(s.substring(start, i + 1));
+            // 进入回溯树的下一层，继续切分 s[i+1..]
+            backtrack(s, i + 1);
+            // 撤销选择
+            track.removeLast();
+        }
+    }
+
+    @Test
+    public void mainWindow() {
+        String s = "ADOBECODEBANC", t = "ABC";
+        System.out.println(minWindow(s, t));
+    }
+
+    /**
+     * 找出最小的字符串
+     *
+     * @param s
+     * @param t
+     * @return
+     */
+    public String minWindow(String s, String t) {
+        String res = "";
+        Map<Character, Integer> need = new HashMap<>();
+        Map<Character, Integer> windows = new HashMap<>();
+        for (int i = 0; i < t.length(); i++) {
+            char c = t.charAt(i);
+            need.put(c, need.getOrDefault(c, 0) + 1);
+        }
+        int left = 0, right = 0, len = Integer.MAX_VALUE, start = 0;
+        int valid = 0;
+        while (right < s.length()) {
+            char c = s.charAt(right);
+            right++;
+            if (need.containsKey(c)) {
+                windows.put(c, windows.getOrDefault(c, 0) + 1);
+                if (windows.get(c).equals(need.get(c))) {
+                    valid++;
+                }
+            }
+            // 判断是否要收缩
+            while (valid == need.size()) {
+                // update
+                if (right - left < len) {
+                    start = left;
+                    len = right - left;
+                }
+                char d = s.charAt(left);
+                left++;
+                if (need.containsKey(d)) {
+                    // 只有相同的时候，才可以
+                    if (windows.get(d).equals(need.get(d))) {
+                        valid--;
+                    }
+                    windows.put(d, windows.get(d) - 1);
+                }
+            }
+        }
+        return len == Integer.MAX_VALUE ? "" : s.substring(start, start + len);
+    }
+
+    @Test
+    public void main() {
+        // 测试出该有的数据
+        int s = 2 << 3;
+        System.out.println(s);
+    }
+
+    public List<Integer> findSubstring(String s, String[] words) {
+        return null;
+    }
+
+    /**
+     * 所有的组合一起。
+     *
+     * @param words
+     * @return
+     */
+    public List<String> dfs(String[] words) {
+        int len = words.length;
+        boolean[] used = new boolean[len];
+        final ArrayList<String> list = new ArrayList<>();
+        dfs(words, used, new LinkedList<String>(), list);
+        return list;
+    }
+
+    /**
+     * 有3个元素的时候。是怎么结束的呢？
+     *
+     * @param words
+     * @param used
+     * @param connect
+     * @param list
+     * @return
+     */
+    public void dfs(String[] words, boolean[] used, LinkedList<String> connect, List<String> list) {
+        if (connect.size() == words.length) {
+            final String collect = connect.stream().collect(Collectors.joining());
+            list.add(collect);
+            return;
+        }
+        int len = words.length;
+        for (int i = 0; i < len; i++) {
+            if (used[i]) {
+                continue;
+            }
+            String s = words[i];
+            used[i] = true;
+            connect.add(s);
+            dfs(words, used, connect, list);
+            used[i] = false;
+            connect.removeLast();
+        }
+    }
+
+    void backtrack(int[] nums, LinkedList<Integer> track, boolean[] used) {
+        // 触发结束条件
+        if (track.size() == nums.length) {
+//            res.add(new LinkedList(track));
+            return;
+        }
+
+        for (int i = 0; i < nums.length; i++) {
+            // 排除不合法的选择
+            if (used[i]) {
+                // nums[i] 已经在 track 中，跳过
+                continue;
+            }
+            // 做选择
+            track.add(nums[i]);
+            used[i] = true;
+            // 进入下一层决策树
+            backtrack(nums, track, used);
+            // 取消选择
+            track.removeLast();
+            used[i] = false;
+        }
+    }
+
+    @Test
+    public void testGroup() {
+        String[] words = {"ab", "cd", "ef"};
+        // "abcdef"， "abefcd"，"cdabef"， "cdefab"，"efabcd"， 和 "efcdab"
+        System.out.println(dfs(words));
+    }
+
+    public static List<String> generatePermutations(String[] words) {
+        List<String> result = new ArrayList<>();
+        backtrack(result, words, 0);
+        return result;
+    }
+
+    private static void backtrack(List<String> result, String[] words, int index) {
+        if (index == words.length - 1) {
+            result.add(String.join("", words));
+            return;
+        }
+
+        for (int i = index; i < words.length; i++) {
+            // 交换元素
+            log.info("i:" + i + "\tindex:" + index);
+            swap(words, index, i);
+            backtrack(result, words, index + 1);
+            // 恢复原始顺序，回溯
+            swap(words, index, i);
+        }
+    }
+
+    private static void swap(String[] words, int i, int j) {
+        String temp = words[i];
+        words[i] = words[j];
+        words[j] = temp;
+    }
+
+    public static List<String> generatePermutationsGeneral(String[] words) {
+        List<String> result = new ArrayList<>();
+        backtrack(result, words, new boolean[words.length], new StringBuilder(), 0);
+        return result;
+    }
+
+    private static void backtrack(List<String> result, String[] words, boolean[] used, StringBuilder current, int count) {
+        if (count == words.length) {
+            result.add(current.toString());
+            return;
+        }
+
+        for (int i = 0; i < words.length; i++) {
+            if (!used[i]) {
+//                for (int j = 0; j < words[i].length(); j++) {
+                current.append(words[i]);
+                used[i] = true;
+                backtrack(result, words, used, current, ++count);
+                current.deleteCharAt(words[i].length() - 1);
+                used[i] = false;
+            }
+        }
+    }
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/abTest/TestImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/abTest/TestImpl.java b/common/core/src/main/java/org/example/common/core/leetcode/abTest/TestImpl.java
new file mode 100644
--- /dev/null	(date 1698633783357)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/abTest/TestImpl.java	(date 1698633783357)
@@ -0,0 +1,34 @@
+package org.example.common.core.leetcode.abTest;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/18 15:21
+ */
+public class TestImpl extends Test{
+    @Override
+    void method() {
+        System.out.println("I am a subClass method");
+    }
+
+    private static int j = 0;
+
+    private static Boolean methodB(int k) {
+        j += k;
+        return true;
+    }
+
+    public static void methodA(int i) {
+        boolean b;
+        b = i < 10 | methodB(4);
+        b = i < 10 || methodB(8);
+
+    }
+
+    public static void main(String[] args) {
+        methodA(0);
+        System.out.println(j);
+    }
+
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/abTest/Employee.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/abTest/Employee.java b/common/core/src/main/java/org/example/common/core/leetcode/abTest/Employee.java
new file mode 100644
--- /dev/null	(date 1698633783352)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/abTest/Employee.java	(date 1698633783352)
@@ -0,0 +1,99 @@
+package org.example.common.core.leetcode.abTest;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/19 15:49
+ */
+class Person {
+    String name = "No name";
+    public Person(String nm) {
+        name = nm;
+    }
+}
+class Employee extends Person {
+    String empID = "0000";
+    public Employee(String id) {
+        super("999");
+        empID = id;
+    }
+}
+class Test2 {
+    public static void main(String args[]) {
+
+        String s1 = "Coder";
+        String s2 = "Coder";
+        String s3 = "Coder" + s2;
+        String s4 = "Coder" + "Coder";
+        String s5 = s1+s2;
+        System.out.println(s4 == s3);
+        System.out.println(s5 == s3);
+        System.out.println(s4 == "CoderCoder");
+//        System.out.println(s4 == s3);
+    }
+
+    private float f = 1.0f;
+    static class InnerClass{
+        protected static float func() {
+            // 静态要调用静态变量。
+            return 0.1f;
+        }
+    }
+
+}
+
+
+class A {
+    public A foo() {
+        return this;
+    }
+}
+
+class B extends A{
+    @Override
+    public A foo(){
+        return this;
+    }
+}
+
+class C extends B {
+
+    public A foo(B b) {
+        return b;
+    }
+}
+
+class Base {
+    public void methodOne() {
+        System.out.println("a");
+        methodTwo();
+    }
+
+    public void methodTwo() {
+        System.out.println("B");
+    }
+}
+
+class Derive extends Base{
+    @Override
+    public void methodOne() {
+        super.methodOne();
+        System.out.println("C");
+    }
+
+    @Override
+    public void methodTwo()  {
+        super.methodTwo();
+        System.out.println("D");
+    }
+}
+
+/**
+ * 执行了
+ * Base a = new Derive();
+ * a.methodOne(); 输出的是ABDC；
+ *
+ */
+
+
Index: common/core/src/main/java/org/example/common/core/leetcode/abTest/A1023.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/abTest/A1023.java b/common/core/src/main/java/org/example/common/core/leetcode/abTest/A1023.java
new file mode 100644
--- /dev/null	(date 1698633783350)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/abTest/A1023.java	(date 1698633783350)
@@ -0,0 +1,37 @@
+package org.example.common.core.leetcode.abTest;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/23 15:05
+ */
+public class A1023 {
+    public static void main(String[] args) {
+        List<? extends A1023> list = new ArrayList<B1023>();
+        int i = 0;
+        int a = i++;
+        int b = ++a;
+        int c = a + b;
+        int d = (a == 1) ? b : c;
+        System.out.printf("a:%d;d:%d",a,d);
+    }
+}
+
+class B1023 extends A1023 {
+
+}
+
+class C1023 extends B1023 {
+
+}
+
+class D extends B1023 {
+
+}
+
+
+
Index: common/core/src/main/java/org/example/common/core/leetcode/abTest/MyApplication.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/abTest/MyApplication.java b/common/core/src/main/java/org/example/common/core/leetcode/abTest/MyApplication.java
new file mode 100644
--- /dev/null	(date 1698633783354)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/abTest/MyApplication.java	(date 1698633783354)
@@ -0,0 +1,23 @@
+package org.example.common.core.leetcode.abTest;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/19 9:42
+ */
+class Test1 {
+    public static void hello() {
+        System.out.println("hello");
+    }
+}
+public class MyApplication {
+    public static void main(String[] args) {
+        byte b = (byte)130;
+        System.out.println(b);
+
+    }
+    void fermin(int i){
+        i++;
+    }
+}
Index: common/core/src/main/java/org/example/common/core/design/NullObject.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/design/NullObject.java b/common/core/src/main/java/org/example/common/core/design/NullObject.java
new file mode 100644
--- /dev/null	(date 1698993250782)
+++ b/common/core/src/main/java/org/example/common/core/design/NullObject.java	(date 1698993250782)
@@ -0,0 +1,25 @@
+package org.example.common.core.design;
+
+import org.openjdk.jol.info.ClassLayout;
+
+import java.util.ArrayList;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/11/2 13:27
+ */
+public class NullObject {
+
+
+    public static class TestNotNull {
+        private NullObject nullObject=new NullObject();
+        private int a;
+
+        public static void main(String[] args) {
+            System.out.println(ClassLayout.parseInstance(new TestNotNull()));
+        }
+    }
+
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1104.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1104.java b/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1104.java
new file mode 100644
--- /dev/null	(date 1699089284296)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1104.java	(date 1699089284296)
@@ -0,0 +1,42 @@
+package org.example.common.core.leetcode.daily;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description: 回文序列、字串
+ * @time: 2023/11/4 16:58
+ */
+public class Leet1104 {
+
+    /**
+     * 寻找回文
+     *
+     * @param s
+     * @return
+     */
+    public int longestPalindrome(String s) {
+
+    }
+
+    public S
+
+    /**
+     * 最长回文子序列
+     *
+     * @param s
+     * @return
+     */
+    public int longestPalindromeSubseq(String s) {
+
+    }
+
+    /**
+     *  最长的回文子串
+     *
+     * @param s
+     * @return
+     */
+    public String longestPalindrome(String s) {
+
+    }
+}
Index: stock/src/main/java/com/example/stock/basic/CompleteFutureTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.stock.basic;\r\n\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.example.common.core.util.FileUtils;\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.nio.file.Paths;\r\nimport java.util.*;\r\nimport java.util.concurrent.*;\r\nimport java.util.function.BiConsumer;\r\nimport java.util.function.Function;\r\nimport java.util.stream.Collectors;\r\n\r\n/**\r\n * @Author: lejun\r\n * @project: cloud\r\n * @description:\r\n * @time: 2023/1/7 19:26\r\n */\r\n@Slf4j\r\npublic class CompleteFutureTest {\r\n    public static String path = \"C:\\\\Users\\\\lejun\\\\Desktop\\\\world\\\\test\";\r\n\r\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\r\n\r\n//        // step1:异步执行\r\n//        Runnable runnable = () -> {\r\n//            System.out.println(\"执行无返回结果的异步任务-开始\");\r\n//            try {\r\n//                TimeUnit.SECONDS.sleep(5);\r\n//            } catch (InterruptedException e) {\r\n//                e.printStackTrace();\r\n//            }\r\n//            System.out.println(\"执行无返回结果的异步任务-结束\");\r\n//\r\n//        };\r\n//        CompletableFuture.runAsync(runnable);\r\n//\r\n//        // step2:异步执行 阻塞获取结果\r\n//        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\r\n//            System.out.println(\"执行有返回值的异步任务\");\r\n//            try {\r\n//                TimeUnit.SECONDS.sleep(5);\r\n//            } catch (InterruptedException e) {\r\n//                e.printStackTrace();\r\n//            }\r\n//            return \"Hello World\";\r\n//        });\r\n//        String result = future.get();\r\n//        System.out.println(result);\r\n//\r\n//        // step3:异步执行 阻塞获取结果后对结果进行运算处理 不改变最终结果\r\n//        String result2 = future.whenComplete(new BiConsumer<String, Throwable>() {\r\n//            @Override\r\n//            public void accept(String t, Throwable action) {\r\n//                t = t + 1;\r\n//                System.out.println(\"任务执行后结果处理\");\r\n//            }\r\n//        }).exceptionally(new Function<Throwable, String>() {\r\n//            @Override\r\n//            public String apply(Throwable t) {\r\n//                System.out.println(\"任务执行后结果额外处理-如果有异常进入此处\");\r\n//                return \"异常结果\";\r\n//            }\r\n//        }).get();\r\n//\r\n//        System.out.println(\"最终结果\" + result2);\r\n\r\n        // step4:\r\n        // thenCombine会将两个任务的执行结果作为所提供函数的参数，且该方法有返回值；\r\n        // thenAcceptBoth同样将两个任务的执行结果作为方法入参，但是无返回值；\r\n        // runAfterBoth没有入参，也没有返回值。注意两个任务中只要有一个执行异常，则将该异常信息作为指定任务的执行结果\r\n\r\n        CompletableFuture<Integer> cf1 = CompletableFuture.supplyAsync(() -> {\r\n            System.out.println(Thread.currentThread() + \" cf1 do something....\");\r\n            return 1;\r\n        });\r\n\r\n        CompletableFuture<Integer> cf2 = CompletableFuture.supplyAsync(() -> {\r\n            System.out.println(Thread.currentThread() + \" cf2 do something....\");\r\n            return 2;\r\n        });\r\n\r\n        CompletableFuture<Integer> cf3 = cf1.thenCombine(cf2, (a, b) -> {\r\n            System.out.println(Thread.currentThread() + \" cf3 do something....\");\r\n            return a + b;\r\n        });\r\n\r\n        System.out.println(\"cf3结果->\" + cf3.get());\r\n\r\n        CompletableFuture<Integer> cf4 = CompletableFuture.supplyAsync(() -> {\r\n            System.out.println(Thread.currentThread() + \" cf4 do something....\");\r\n            return 1;\r\n        });\r\n\r\n        CompletableFuture<Integer> cf5 = CompletableFuture.supplyAsync(() -> {\r\n            System.out.println(Thread.currentThread() + \" cf5 do something....\");\r\n            return 2;\r\n        });\r\n\r\n        CompletableFuture<Void> cf6 = cf4.thenAcceptBoth(cf5, (a, b) -> {\r\n            System.out.println(Thread.currentThread() + \" cf6 do something....\");\r\n            System.out.println(\"处理结果不返回：\" + (a + b));\r\n        });\r\n\r\n        System.out.println(\"cf3结果->\" + cf6.get());\r\n\r\n\r\n        // step5:\r\n        //allOf:\r\n        // CompletableFuture是多个任务都执行完成后才会执行，只有有一个任务执行异常，则返回的CompletableFuture执行get方法时会抛出异常，如果都是正常执行，则get返回null。\r\n        //anyOf:\r\n        // CompletableFuture是多个任务只要有一个任务执行完成，则返回的CompletableFuture执行get方法时会抛出异常，如果都是正常执行，则get返回执行完成任务的结果。\r\n//        CompletableFuture<String> cf7 = CompletableFuture.supplyAsync(() -> {\r\n//            try {\r\n//                System.out.println(Thread.currentThread() + \" cf7 do something....\");\r\n//                Thread.sleep(2000);\r\n//            } catch (InterruptedException e) {\r\n//                e.printStackTrace();\r\n//            }\r\n//            System.out.println(\"cf7 任务完成\");\r\n//            return \"cf7 任务完成\";\r\n//        });\r\n//\r\n//        CompletableFuture<String> cf8 = CompletableFuture.supplyAsync(() -> {\r\n//            try {\r\n//                System.out.println(Thread.currentThread() + \" cf8 do something....\");\r\n//                Thread.sleep(5000);\r\n//            } catch (InterruptedException e) {\r\n//                e.printStackTrace();\r\n//            }\r\n//            System.out.println(\"cf8 任务完成\");\r\n//            return \"cf8 任务完成\";\r\n//        });\r\n//\r\n//        CompletableFuture<String> cf9 = CompletableFuture.supplyAsync(() -> {\r\n//            try {\r\n//                System.out.println(Thread.currentThread() + \" cf9 do something....\");\r\n//                Thread.sleep(3000);\r\n//            } catch (InterruptedException e) {\r\n//                e.printStackTrace();\r\n//            }\r\n//            System.out.println(\"cf9 任务完成\");\r\n//            return \"cf9 任务完成\";\r\n//        });\r\n//        /*\r\n//        CompletableFuture<Void> cfAll = CompletableFuture.allOf(cf7, cf8, cf9);\r\n//        System.out.println(\"cfAll结果->\" + cfAll.get());\r\n//        */\r\n//        CompletableFuture<Object> cfAny = CompletableFuture.anyOf(cf7, cf8, cf9);\r\n//        System.out.println(\"cfAny结果->\" + cfAny.get());\r\n    }\r\n\r\n    @Test\r\n    public void main() throws ExecutionException, InterruptedException, IOException {\r\n        ExecutorService executorService = Executors.newFixedThreadPool(2);\r\n        List<Map<String, List<String>>> futureList = new ArrayList<>();\r\n        CompletableFuture[] futures = new CompletableFuture[2];\r\n        CompletableFuture<Map<String, List<String>>> future1 = CompletableFuture.supplyAsync(() -> {\r\n            Map<String, List<String>> result = new HashMap<>();\r\n            try {\r\n                result = dealMessage();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n            return result;\r\n        });\r\n        futures[0] = future1;\r\n        CompletableFuture<Map<String, List<String>>> future2 = CompletableFuture.supplyAsync(() -> {\r\n            return dealVoice();\r\n        });\r\n        futures[1] = future2;\r\n        CompletableFuture<Void> allFuture = CompletableFuture.allOf(futures);\r\n\r\n        List<Map<String, List<String>>> maps = allFuture.thenApply(v -> Arrays.stream(futures)\r\n                .map(CompletableFuture<Map<String, List<String>>>::join).collect(Collectors.toList())).get();\r\n        executorService.shutdown();\r\n        // 对delete的目录删除\r\n        for (Map<String, List<String>> map : maps) {\r\n            List<String> delete = map.get(\"delete\");\r\n            for (String s : delete) {\r\n                File file = Paths.get(s).toFile();\r\n                if (file.isDirectory()) {\r\n                    List<String> strings = FileUtils.readFileName(s);\r\n                    log.info(\"{}文件夹下如下文件{}\", s, strings);\r\n                    strings.forEach(p->{\r\n                        new File(p).delete();\r\n                    });\r\n                }\r\n                file.delete();\r\n                log.info(\"{}已被删除\", s);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * ExecutorService executorService = Executors.newFixedThreadPool(5);\r\n         *List<String> list = Arrays.asList(\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\");\r\n         *List<CompletableFuture<String>> futureList = list.stream()\r\n         .map(str -> printStr(str, executorService)).collect(Collectors.toList());\r\n         *CompletableFuture<Void> allFuture = CompletableFuture.allOf(futureList.toArray(new CompletableFuture[futureList.size()]));\r\n         *CompletableFuture<List<String>> resultFuture =\r\n         *log.info(\"result:{}\", resultFuture.get());\r\n         *executorService.shutdown();\r\n         *\r\n         */\r\n\r\n    }\r\n\r\n    public Map<String, List<String>> dealVoice() {\r\n        Map<String, List<String>> map = new HashMap<>();\r\n        String file = \"C:\\\\Users\\\\lejun\\\\Desktop\\\\world\\\\test\\\\voice\";\r\n        String target = \"C:\\\\Users\\\\lejun\\\\Desktop\\\\world\\\\test\\\\语音\\\\voice.zip\";\r\n        FileUtils.zip(file, target);\r\n        map.put(\"delete\", Arrays.asList(file));\r\n        map.put(\"file\", Arrays.asList(\"C:\\\\Users\\\\lejun\\\\Desktop\\\\world\\\\test\\\\语音\"));\r\n        log.info(\"已完成语音处理！\");\r\n        return map;\r\n    }\r\n\r\n    public Map<String, List<String>> dealMessage() throws IOException {\r\n        Map<String, List<String>> map = new HashMap<>();\r\n        String file = \"C:\\\\Users\\\\lejun\\\\Desktop\\\\world\\\\test\\\\message\";\r\n        String target = \"C:\\\\Users\\\\lejun\\\\Desktop\\\\world\\\\test\\\\短信\\\\message.zip\";\r\n        FileUtils.zip(file, target);\r\n        map.put(\"delete\", Arrays.asList(file));\r\n        for (String s : Arrays.asList(file)) {\r\n            File deleteFile = Paths.get(s).toFile();\r\n            if (deleteFile.isDirectory()) {\r\n                List<String> strings = FileUtils.readFileName(s);\r\n                log.info(\"{}文件夹下如下文件{}\", s, strings);\r\n                strings.forEach(p->{\r\n                    new File(p).delete();\r\n                });\r\n            }\r\n            deleteFile.delete();\r\n            log.info(\"{}已被删除\", s);\r\n        }\r\n        map.put(\"file\", Arrays.asList(\"C:\\\\Users\\\\lejun\\\\Desktop\\\\world\\\\test\\\\短信\"));\r\n        log.info(\"已完成短信处理！\");\r\n        return map;\r\n    }\r\n\r\n    @Test\r\n    public void zipTs() {\r\n        dealVoice();\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/stock/src/main/java/com/example/stock/basic/CompleteFutureTest.java b/stock/src/main/java/com/example/stock/basic/CompleteFutureTest.java
--- a/stock/src/main/java/com/example/stock/basic/CompleteFutureTest.java	(revision cf8ea38fa9da362ec8a79646980a64be2e30bae6)
+++ b/stock/src/main/java/com/example/stock/basic/CompleteFutureTest.java	(date 1698633783468)
@@ -2,17 +2,19 @@
 
 import lombok.extern.slf4j.Slf4j;
 import org.example.common.core.util.FileUtils;
-import org.junit.jupiter.api.Test;
+import org.junit.Test;
 
 import java.io.File;
 import java.io.IOException;
 import java.nio.file.Paths;
 import java.util.*;
-import java.util.concurrent.*;
-import java.util.function.BiConsumer;
-import java.util.function.Function;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 import java.util.stream.Collectors;
 
+
 /**
  * @Author: lejun
  * @project: cloud
@@ -212,7 +214,7 @@
         Map<String, List<String>> map = new HashMap<>();
         String file = "C:\\Users\\lejun\\Desktop\\world\\test\\voice";
         String target = "C:\\Users\\lejun\\Desktop\\world\\test\\语音\\voice.zip";
-        FileUtils.zip(file, target);
+//        FileUtils.zip(file, target);
         map.put("delete", Arrays.asList(file));
         map.put("file", Arrays.asList("C:\\Users\\lejun\\Desktop\\world\\test\\语音"));
         log.info("已完成语音处理！");
@@ -223,7 +225,7 @@
         Map<String, List<String>> map = new HashMap<>();
         String file = "C:\\Users\\lejun\\Desktop\\world\\test\\message";
         String target = "C:\\Users\\lejun\\Desktop\\world\\test\\短信\\message.zip";
-        FileUtils.zip(file, target);
+//        FileUtils.zip(file, target);
         map.put("delete", Arrays.asList(file));
         for (String s : Arrays.asList(file)) {
             File deleteFile = Paths.get(s).toFile();
Index: common/core/src/main/java/org/example/common/core/leetcode/test.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/test.json b/common/core/src/main/java/org/example/common/core/leetcode/test.json
new file mode 100644
--- /dev/null	(date 1698633783448)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/test.json	(date 1698633783448)
@@ -0,0 +1,2 @@
+{"I", "V", "X", "L", "C", "D", "M"}
+{"1" "5", "10", "50", "100", "500", "1000"}
\ No newline at end of file
Index: common/web/src/main/java/org/example/web/meituan/TimeProblem.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/web/src/main/java/org/example/web/meituan/TimeProblem.java b/common/web/src/main/java/org/example/web/meituan/TimeProblem.java
new file mode 100644
--- /dev/null	(date 1699000960101)
+++ b/common/web/src/main/java/org/example/web/meituan/TimeProblem.java	(date 1699000960101)
@@ -0,0 +1,33 @@
+package org.example.web.meituan;
+
+import java.text.SimpleDateFormat;
+import java.util.Calendar;
+import java.util.Locale;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/11/3 16:34
+ */
+public class TimeProblem {
+    private volatile int a = 10;
+    /**
+     * 出现这个问题的原因在于，这位同学混淆了 SimpleDateFormat 的各种格式化模式。JDK 的文档中有说明：小写 y 是年，而大写 Y 是 week year，也就是所在的周属于哪一年。
+     *
+     * 一年第一周的判断方式是，从 getFirstDayOfWeek() 开始，完整的 7 天，并且包含那一年至少 getMinimalDaysInFirstWeek() 天。这个计算方式和区域相关，对于当前 zh_CN 区域来说，2020 年第一周的条件是，从周日开始的完整 7 天，2020 年包含 1 天即可。显然，2019 年 12 月 29 日周日到 2020 年 1 月 4 日周六是 2020 年第一周，得出的 week year 就是 2020 年。
+     *
+     * @param args
+     */
+    public static void main(String[] args) {
+        Locale.setDefault(Locale.SIMPLIFIED_CHINESE);
+        System.out.println("defaultLocale:" + Locale.getDefault());
+        Calendar calendar = Calendar.getInstance();
+        calendar.set(2019, Calendar.DECEMBER, 29,0,0,0);
+        SimpleDateFormat YYYY = new SimpleDateFormat("YYYY-MM-dd");
+        System.out.println("格式化: " + YYYY.format(calendar.getTime()));
+        System.out.println("weekYear:" + calendar.getWeekYear());
+        System.out.println("firstDayOfWeek:" + calendar.getFirstDayOfWeek());
+        System.out.println("minimalDaysInFirstWeek:" + calendar.getMinimalDaysInFirstWeek());
+    }
+}
Index: common/web/src/main/java/org/example/web/meituan/ThreadLocalProblem.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.example.web.meituan;\r\n\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RequestParam;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\n/**\r\n * @Author: lejun\r\n * @project: cloud\r\n * @description:\r\n * @time: 2023/11/3 15:26\r\n */\r\npublic class ThreadLocalProblem {\r\n    private static final ThreadLocal<Integer> currentUser = ThreadLocal.withInitial(() -> null);\r\n\r\n    @GetMapping(\"wrong\")\r\n    public Map wrong(@RequestParam(\"userId\") Integer userId) {\r\n        //设置用户信息之前先查询一次ThreadLocal中的用户信息\r\n        String before  = Thread.currentThread().getName() + \":\" + currentUser.get();\r\n        //设置用户信息到ThreadLocal\r\n        currentUser.set(userId);\r\n        //设置用户信息之后再查询一次ThreadLocal中的用户信息\r\n        String after  = Thread.currentThread().getName() + \":\" + currentUser.get();\r\n        //汇总输出两次查询结果\r\n        Map result = new HashMap();\r\n        result.put(\"before\", before);\r\n        result.put(\"after\", after);\r\n        return result;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/web/src/main/java/org/example/web/meituan/ThreadLocalProblem.java b/common/web/src/main/java/org/example/web/meituan/ThreadLocalProblem.java
--- a/common/web/src/main/java/org/example/web/meituan/ThreadLocalProblem.java	(revision cf8ea38fa9da362ec8a79646980a64be2e30bae6)
+++ b/common/web/src/main/java/org/example/web/meituan/ThreadLocalProblem.java	(date 1698997493869)
@@ -1,5 +1,6 @@
 package org.example.web.meituan;
 
+import lombok.extern.slf4j.Slf4j;
 import org.springframework.web.bind.annotation.GetMapping;
 import org.springframework.web.bind.annotation.RequestParam;
 
@@ -12,6 +13,7 @@
  * @description:
  * @time: 2023/11/3 15:26
  */
+@Slf4j
 public class ThreadLocalProblem {
     private static final ThreadLocal<Integer> currentUser = ThreadLocal.withInitial(() -> null);
 
@@ -29,4 +31,28 @@
         result.put("after", after);
         return result;
     }
+
+    @GetMapping("good")
+    public String good() throws InterruptedException {
+//        StopWatch stopWatch = new StopWatch();
+//        stopWatch.start("normaluse");
+//        Map<String, Long> normaluse = normaluse();
+//        stopWatch.stop();
+//        //校验元素数量
+//        Assert.isTrue(normaluse.size() == ITEM_COUNT, "normaluse size error");
+//        //校验累计总数
+//        Assert.isTrue(normaluse.entrySet().stream()
+//                        .mapToLong(item -> item.getValue()).reduce(0, Long::sum) == LOOP_COUNT
+//                , "normaluse count error");
+//        stopWatch.start("gooduse");
+//        Map<String, Long> gooduse = gooduse();
+//        stopWatch.stop();
+//        Assert.isTrue(gooduse.size() == ITEM_COUNT, "gooduse size error");
+//        Assert.isTrue(gooduse.entrySet().stream()
+//                        .mapToLong(item -> item.getValue())
+//                        .reduce(0, Long::sum) == LOOP_COUNT
+//                , "gooduse count error");
+//        log.info(stopWatch.prettyPrint());
+        return "OK";
+    }
 }
Index: common/core/src/main/java/org/example/common/core/leetcode/arr/ArrSolution.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/arr/ArrSolution.java b/common/core/src/main/java/org/example/common/core/leetcode/arr/ArrSolution.java
new file mode 100644
--- /dev/null	(date 1698633783376)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/arr/ArrSolution.java	(date 1698633783376)
@@ -0,0 +1,342 @@
+package org.example.common.core.leetcode.arr;
+
+import lombok.extern.slf4j.Slf4j;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.locks.ReentrantLock;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/9/22 14:48
+ */
+@Slf4j
+public class ArrSolution {
+    /**
+     * 数组的值最多2次重复；
+     * 用O(1)的空间度
+     *
+     * @param nums
+     * @return
+     */
+    public int removeDuplicates(int[] nums) {
+        int n = nums.length;
+        if (n == 0) {
+            return n;
+        }
+        int slow = 0, fast = 0;
+        int count = 0;
+        while (fast < n) {
+            if (nums[fast] != nums[slow]) {
+                slow++;
+                nums[slow] = nums[fast];
+            } else if (slow < fast && count < 2) {
+                slow++;
+                nums[slow] = nums[fast];
+            }
+            fast++;
+            count++;
+            if (fast < n && nums[fast] != nums[fast - 1]) {
+                // fast 遇到不同的元素，重置count；
+                count = 0;
+            }
+        }
+        return slow + 1;
+    }
+
+    @Test
+    public void main() {
+        int[] nums = {1, 1, 1, 2, 2, 3};
+        final int i = removeDuplicates(nums);
+        log.info("{}", i);
+    }
+
+    /**
+     * 只出现一次的数组
+     *
+     * @param nums
+     * @return
+     */
+    public int removeDuplicatesOnlyOne(int[] nums) {
+        // 和上面一样的思路！
+        return 0;
+    }
+
+    /**
+     * 左右规则。
+     *
+     * @param ratings
+     * @return
+     */
+    public int candy(int[] ratings) {
+        int n = ratings.length;
+        int[] left = new int[n];
+        int[] right = new int[n];
+        Arrays.fill(left, 1);
+        Arrays.fill(right, 1);
+        for (int i = 1; i < n; i++) {
+            if (ratings[i] > ratings[i - 1]) {
+                left[i] = left[i - 1] + 1;
+            }
+        }
+        int count = left[n - 1];
+        for (int i = n - 2; i >= 0; i--) {
+            if (ratings[i] > ratings[i + 1]) {
+                right[i] = right[i + 1] + 1;
+                count += Math.max(left[i], right[i]);
+            }
+        }
+        return count;
+    }
+
+    /**
+     * 环形的数组求一个可行解
+     *
+     * @param gas
+     * @param cost
+     * @return
+     */
+    public int canCompleteCircuit(int[] gas, int[] cost) {
+        int n = gas.length;
+        int sum = 0, minSum = 0;
+        int start = 0;
+        for (int i = 0; i < n; i++) {
+            sum += gas[i] - cost[i];
+            log.info("第{}处相差：{}", i, sum);
+            /**
+             * 这里的解释是什么？
+             * <p>
+             *     为什么他的起点是变为了i+1?
+             *     A:因为有题目的要求的。
+             * </p>
+             */
+            if (sum < minSum) {
+                // 因为有题目说明的意思。
+                start = i + 1;
+                minSum = sum;
+            }
+        }
+        if (sum < 0) {
+            log.info("此问题无解，请检查是否有可行解！");
+            return -1;
+        }
+        // 会有start == n 的情况出现？为啥
+        return start == n ? 0 : start;
+    }
+
+    @Test
+    public void testGas() {
+        int[] gas = {4, 5, 1, 2, 3};
+        int[] cost = {1, 2, 3, 4, 5};
+        System.out.println(canCompleteCircuit(gas, cost));
+    }
+
+    /**
+     * <h1>最长的公共前缀</h1>
+     *
+     * <b>我是连基本的参照物准则都没有搞懂的人啊！</b>
+     *
+     * @param strs
+     * @return
+     */
+    public String longestCommonPrefixMe(String[] strs) {
+        if (strs == null || strs.length == 1) {
+            return "";
+        }
+        int n = strs.length;
+        StringBuilder sb = new StringBuilder();
+        String s = strs[0];
+        for (int i = 1; i < n; i++) {
+            String temp = strs[i];
+            char[] chars = temp.toCharArray();
+            for (int j = 0; j < chars.length; j++) {
+                if (s.charAt(j) != 'a' ) {
+                    return "";
+                }
+            }
+        }
+        return sb.toString();
+    }
+
+    public String longestCommonPrefix(String[] strs) {
+        ReentrantLock lock = new ReentrantLock();
+        int m = strs.length;
+        // 以第一行的列数为基准
+        int n = strs[0].length();
+        for (int col = 0; col < n; col++) {
+            for (int row = 1; row < m; row++) {
+                String thisStr = strs[row], prevStr = strs[row - 1];
+                // 判断每个字符串的 col 索引是否都相同
+                if (col >= thisStr.length() || col >= prevStr.length() ||
+                        thisStr.charAt(col) != prevStr.charAt(col)) {
+                    // 发现不匹配的字符，只有 strs[row][0..col-1] 是公共前缀
+                    return strs[row].substring(0, col);
+                }
+            }
+        }
+        return strs[0];
+    }
+
+    @Test
+    public void testThree() {
+        int[] nums = {-1,0,1,2,-1,-4};
+        for (int i = 3; i < 6; i++) {
+            final List<List<Integer>> lists = nSum(nums, i);
+            log.info("{}", lists);
+        }
+    }
+
+    /**
+     * 3数之和
+     *
+     * @param nums
+     * @return
+     */
+    public List<List<Integer>> nSum(int[] nums, int n) {
+        Arrays.sort(nums);
+        return nSumTarget(nums, n, 0, 0);
+    }
+
+    private List<List<Integer>> nSumTarget(int[] nums, int n, int start, int target) {
+        int sz = nums.length;
+        List<List<Integer>> res = new ArrayList<>();
+        if (n < 2 || sz < n) {
+            return res;
+        }
+        if (n == 2) {
+            int lo = start, hi = sz - 1;
+            while (lo < hi) {
+                int sum = nums[lo] + nums[hi];
+                int left = nums[lo], right = nums[hi];
+                if (sum < target) {
+                    while (lo < hi && nums[lo] == left) {
+                        lo++;
+                    }
+                } else if (sum > target) {
+                    while (lo < hi && nums[hi] == right) {
+                        hi--;
+                    }
+                } else {
+                    res.add(new ArrayList<Integer>(Arrays.asList(left, right)));
+                    while (lo < hi && nums[lo] == left) {
+                        lo++;
+                    }
+                    while (lo < hi && nums[hi] == right) {
+                        hi--;
+                    }
+                }
+
+            }
+        } else {
+            for (int i = start; i < sz; i++) {
+                List<List<Integer>>
+                        sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);
+                for (List<Integer> arr : sub) {
+                    // (n-1)Sum 加上 nums[i] 就是 nSum
+                    arr.add(nums[i]);
+                    res.add(arr);
+                }
+                while (i < sz - 1 && nums[i] == nums[i + 1]) {
+                    i++;
+                }
+            }
+        }
+        return res;
+    }
+
+    /**
+     * https://labuladong.gitee.io/algo/di-san-zha-24031/jing-dian--a94a0/ru-he-gao--0d5eb/
+     *
+     * @param nums
+     * @return 盛最多水的容器。
+     */
+    public int maxRain(int[] nums) {
+        return 0;
+    }
+
+    /**
+     * <h1>最长连续序列</h1>
+     *
+     * @param nums
+     * @return
+     */
+    public int longestConsecutive(int[] nums) {
+        Arrays.sort(nums);
+        //
+        int maxLen = 0;
+        int len = nums.length;
+        for (int i = 0; i < len; i++) {
+//            // 有很多的重复解。需要优化。
+//            int num = nums[i];
+//            int j = i+1;
+//            while (j < len && (num == nums[j] - 1)) {
+//                num = nums[j];
+//                j++;
+//            }
+//            // 说明不行用下标
+//            maxLen = Math.max(j - i, maxLen);
+//            i = j-1;
+        }
+        return maxLen;
+    }
+
+    @Test
+    public void testLong() {
+        int[] nums = {0,3,7,2,5,8,4,6,0,1};
+        System.out.println(longestConsecutive(nums));
+    }
+
+    public int maxArea(int[] height) {
+        int n = height.length;
+        int maxVolume = 0;
+        int leftMax = 0, rightMax = 0;
+        // 最重要的思路是什么？要求有
+        for(int i = 0, j = n - 1; i < n; i++, j--) {
+            // 有小于maxVolume的话，左边大于右边的话是要怎么移动呢？
+            int cur_area = Math.min(height[i], height[j]) * (j - i);
+            maxVolume = Math.max(maxVolume, cur_area);
+            if (height[i] < height[j]) {
+                i++;
+            } else {
+                j--;
+            }
+        }
+        return maxVolume;
+    }
+
+    /**
+     * 出现了2个数字是单个其他的都是出现了2次。
+     * x1 ^ x2 == y
+     * y & (-y) ==> z 获取到？
+     * z & x1 = (y & (-y)) ^ x
+     *
+     * @param nums
+     * @return
+     */
+    public int[] singleNumber(int[] nums) {
+        int xorAll = 0;
+        for (int x : nums) {
+            xorAll ^= x;
+        }
+        int lowbit = xorAll & -xorAll;
+        int[] ans = new int[2];
+        for (int x : nums) {
+            int res = lowbit ^ x;
+            log.info("{}", res);
+            ans[(x & lowbit) == 0 ? 0 : 1] ^= x; // 分组异或
+            log.info("{}", ans);
+        }
+        return ans;
+    }
+
+    @Test
+    public void mainSingle() {
+        int[] res = new int[]{1,1,2,2,3,5};
+        System.out.println(Arrays.toString(singleNumber(res)));
+    }
+
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/dp/Stock.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.example.common.core.leetcode.dp;\r\n\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.junit.Test;\r\n\r\nimport java.util.Arrays;\r\nimport java.util.concurrent.ConcurrentHashMap;\r\n\r\n/**\r\n * @Author: lejun\r\n * @project: cloud\r\n * @description:\r\n * @time: 2023/10/22 21:38\r\n */\r\n@Slf4j\r\npublic class Stock {\r\n    /**\r\n     * <h1>最大的利润：只能买入以后才能卖出</h1>\r\n     * 基本的定义是什么呢？dp[i][2]\r\n     * i为第i天的最大的数值\r\n     *\r\n     * @param prices\r\n     * @return\r\n     */\r\n    public int maxProfitI(int[] prices) {\r\n        int n = prices.length;\r\n        int[][] dp = new int[n][2];\r\n        for (int i = 0; i < n; i++) {\r\n            if (i - 1 == -1) {\r\n                // base case\r\n                dp[i][0] = 0;\r\n                dp[i][1] = -prices[i];\r\n                continue;\r\n            }\r\n            // 0 shi sell 1 is buy\r\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\r\n            // 前一天有了或者今天买\r\n            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);\r\n        }\r\n        log.info(\"{}\", Arrays.deepToString(dp));\r\n        return dp[n - 1][0];\r\n    }\r\n\r\n    @Test\r\n    public void test() {\r\n        int[] nums = {8, 9, 2, 5, 4, 7, 1};\r\n        maxProfitI(nums);\r\n    }\r\n\r\n    /**\r\n     * <h1>每天都可以操作stock</h1>\r\n     *\r\n     * @param prices\r\n     * @return\r\n     */\r\n    int maxProfit_k_inf(int[] prices) {\r\n        int n = prices.length;\r\n        int[][] dp = new int[n][2];\r\n        for (int i = 0; i < n; i++) {\r\n            if (i - 1 == -1) {\r\n                // base case\r\n                dp[i][0] = 0;\r\n                dp[i][1] = -prices[i];\r\n                continue;\r\n            }\r\n            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);\r\n            // 那么可能的转移状态为前一天已经持有一支股票，\r\n            // 即 dp[i−1][1]\\textit{dp}[i-1][1]dp[i−1][1]，\r\n            // 或者前一天结束时还没有股票，即 dp[i−1][0]\\textit{dp}[i-1][0]dp[i−1][0]，这时候我们要将其买入，并减少 prices[i]\\textit{prices}[i]prices[i] 的收益。\r\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\r\n        }\r\n        return dp[n - 1][0];\r\n    }\r\n\r\n    /**\r\n     * <h1>交易k次的方程</h1>\r\n     * <p>\r\n     * 原始的状态转移方程，没有可化简的地方\r\n     * 卖 +price\r\n     * dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\r\n     * 买 -price\r\n     * dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\r\n     * </p>\r\n     *\r\n     * @param prices\r\n     * @return\r\n     */\r\n    public int maxProfitWithK(int[] prices) {\r\n        int max_k = 2, n = prices.length;\r\n        int[][][] dp = new int[n][max_k + 1][2];\r\n        for (int i = 0; i < n; i++) {\r\n            /**\r\n             * 这个目的是为什么？\r\n             * <p>\r\n             *     <b>因为是符合现实</b>\r\n             * </p>\r\n             *\r\n             */\r\n            for (int k = max_k; k >= 1; k--) {\r\n                if (i - 1 == -1) {\r\n                    // 初始化数据\r\n                    dp[i][k][0] = 0;\r\n                    dp[i][k][1] = -prices[i];\r\n                    continue;\r\n                }\r\n                // 状态转移方程 买、 卖\r\n                dp[i][k][0] = Math.max(dp[i-1][k][1]+prices[i], dp[i-1][k][0]);\r\n\r\n                dp[i][k][1] = Math.max(dp[i-1][k][0]-prices[i], dp[i-1][k][1]);\r\n            }\r\n        }\r\n        return dp[n-1][max_k][0];\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        char c = 127;\r\n        int sum = 200;\r\n        c += 1;\r\n        sum += c;\r\n        System.out.println(sum);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/dp/Stock.java b/common/core/src/main/java/org/example/common/core/leetcode/dp/Stock.java
--- a/common/core/src/main/java/org/example/common/core/leetcode/dp/Stock.java	(revision cf8ea38fa9da362ec8a79646980a64be2e30bae6)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/dp/Stock.java	(date 1698633783406)
@@ -5,6 +5,7 @@
 
 import java.util.Arrays;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.locks.ReentrantLock;
 
 /**
  * @Author: lejun
Index: common/core/src/main/java/org/example/common/core/leetcode/math/MoneyTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/math/MoneyTest.java b/common/core/src/main/java/org/example/common/core/leetcode/math/MoneyTest.java
new file mode 100644
--- /dev/null	(date 1698633783431)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/math/MoneyTest.java	(date 1698633783431)
@@ -0,0 +1,54 @@
+package org.example.common.core.leetcode.math;
+
+import cn.hutool.core.util.NumberUtil;
+
+import java.math.BigDecimal;
+import java.math.RoundingMode;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/17 15:28
+ */
+public class MoneyTest {
+    public static void main(String[] args) {
+        BigDecimal sum = new BigDecimal("1.13");
+        /*
+         2.5   3
+        -2.5  -3
+        -5.5  -6*/
+        sum.setScale(2, RoundingMode.HALF_UP);
+        /**
+         * 银行的业务三大类：存、贷、汇。
+         * 假如有10笔存款，利息分别是0.000、0.001、0.002、0.003、0.004，0.005、0.006、0.007、0.008、0.009。
+         *
+         * 真实的银行家算法处理金额的计算处理是如下的：
+         *
+         * <p>
+         *  5的情况比较复杂，如果5后面还有数字，则进位后舍去；如果5后面没有数字了，那么如果5前面是奇数，则进1，若5前面是偶数直接舍去5。
+         *  举几个例子：
+         *
+         *  3.015 ≈ 3.02 //5后没有数字，其前面是奇数1，则进1；
+         *
+         *  3.045 ≈ 3.04 //5后没有数字，其前面是偶数，直接舍去5；
+         *
+         *  3.04501 ≈ 3.05 //5后面还有数字，则进位后舍去。
+         * </p>
+         **/
+        sum.setScale(2, RoundingMode.HALF_EVEN);
+        String[] strings = {"3.015", "3.045", "3.04501"};
+        for (String string : strings) {
+            BigDecimal temp = new BigDecimal(string);
+        /*
+         2.5   3
+        -2.5  -3
+        -5.5  -6*/
+            temp.setScale(3, RoundingMode.HALF_EVEN);
+            BigDecimal round = NumberUtil.round(temp, 2);
+            System.out.println(round.doubleValue());
+        }
+
+        System.out.println(new BigDecimal("1.25").setScale(1,BigDecimal.ROUND_HALF_EVEN).toString());
+    }
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/math/MathAlg.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/math/MathAlg.java b/common/core/src/main/java/org/example/common/core/leetcode/math/MathAlg.java
new file mode 100644
--- /dev/null	(date 1698633783429)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/math/MathAlg.java	(date 1698633783429)
@@ -0,0 +1,42 @@
+package org.example.common.core.leetcode.math;
+
+import org.junit.Test;
+
+import java.util.List;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/8/31 17:53
+ */
+public class MathAlg {
+    public int singleNumber(int[] nums) {
+        int res = 0;
+        for (int num : nums) {
+            res ^= num;
+        }
+        System.out.println(res);
+        return res;
+    }
+
+    @Test
+    public void main() {
+        singleNumber(new int[]{4,1,2,1,2});
+    }
+
+    /**
+     * 3数和的概念？？
+     * <p>
+     *     基本的思路是什么？有
+     *     【-1,0,1,2,-1,-4】
+     *
+     * </p>
+     *
+     * @param nums
+     * @return
+     */
+    public List<List<Integer>> threeSum(int[] nums) {
+        return null;
+    }
+}
Index: common/core/src/main/java/org/example/common/core/design/Decorateor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/design/Decorateor.java b/common/core/src/main/java/org/example/common/core/design/Decorateor.java
new file mode 100644
--- /dev/null	(date 1698633783339)
+++ b/common/core/src/main/java/org/example/common/core/design/Decorateor.java	(date 1698633783339)
@@ -0,0 +1,62 @@
+package org.example.common.core.design;
+
+import org.junit.Test;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/9/2 16:09
+ */
+public class Decorateor {
+    // 基础咖啡类
+    class Coffee {
+        public int cost() {
+            return 5;
+        }
+    }
+
+    // 调料装饰类
+    class MilkDecorator extends Coffee {
+        private Coffee coffee;
+
+        public MilkDecorator(Coffee coffee) {
+            this.coffee = coffee;
+        }
+
+        @Override
+        public int cost() {
+            return coffee.cost() + 2;
+        }
+    }
+
+    // 另一种调料装饰类
+    class SugarDecorator extends Coffee {
+        private Coffee coffee;
+
+        public SugarDecorator(Coffee coffee) {
+            this.coffee = coffee;
+        }
+
+        @Override
+        public int cost() {
+            return coffee.cost() + 1;
+        }
+    }
+
+    @Test
+    public void main() {
+        // 创建一个基础咖啡
+        Coffee coffee = new Coffee();
+        System.out.println("基础咖啡价格: " + coffee.cost());
+
+        // 加入牛奶装饰
+        MilkDecorator milkCoffee = new MilkDecorator(coffee);
+        System.out.println("2小杯牛奶的价格: " + 2 * milkCoffee.cost());
+
+        // 再加入糖装饰
+        SugarDecorator sugarMilkCoffee = new SugarDecorator(milkCoffee);
+        System.out.println("3颗糖的价格: " + 3 * sugarMilkCoffee.cost());
+
+    }
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/algorithm/Huawei.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/algorithm/Huawei.java b/common/core/src/main/java/org/example/common/core/leetcode/algorithm/Huawei.java
new file mode 100644
--- /dev/null	(date 1698633783361)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/algorithm/Huawei.java	(date 1698633783361)
@@ -0,0 +1,737 @@
+package org.example.common.core.leetcode.algorithm;
+
+
+import lombok.extern.slf4j.Slf4j;
+import org.junit.Test;
+
+import java.util.*;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/9/7 21:46
+ */
+@Slf4j
+public class Huawei {
+    public static void main1() {
+        Scanner scanner = new Scanner(System.in);
+        int[] ints = Arrays.stream(scanner.nextLine().split(","))
+                .mapToInt(Integer::parseInt).toArray();
+        System.out.println(getResult(ints));
+    }
+
+    /**
+     * 因为是输入的。要明确的表达出
+     */
+    public static String getResult(int[] priority) {
+        int n = priority.length;
+        LinkedList<int[]> link = new LinkedList<>();
+        for (int i = 0; i < n; i++) {
+            link.add(new int[]{priority[i], i});
+        }
+
+        Arrays.sort(priority);
+        int maxI = n - 1;
+
+        int[] ans = new int[n];
+
+        int printIdx = 0;
+        while (link.size() > 0) {
+            int[] tmp = link.removeFirst();
+            int p = tmp[0], i = tmp[1];
+
+            if (p == priority[maxI]) {
+                ans[i] = printIdx;
+                printIdx++;
+                maxI--;
+            } else {
+                link.add(tmp);
+            }
+        }
+
+        StringJoiner sj = new StringJoiner(",");
+        for (int an : ans) {
+            sj.add(an + "");
+        }
+        return sj.toString();
+    }
+
+    public static void main2(String[] args) {
+        Scanner scanner = new Scanner(System.in);
+        String s = scanner.nextLine();
+        // 统计字符的个数。
+        int[] chars = new int[26];
+        String sl = s.toLowerCase();
+        for (int i = 0; i < sl.length(); i++) {
+            int c = sl.charAt(i) - 'a';
+            chars[c]++;
+        }
+        // 输出对应的结果；
+        StringBuffer stringBuffer = new StringBuffer();
+        // 0~25 分别代表了26个字母。
+        LinkedHashMap<Character, Integer> map = new LinkedHashMap<>();
+        for (int i = 0; i < 26; i++) {
+            if (chars[i] > 0) {
+                map.put((char) ('a' + i), chars[i]);
+            }
+        }
+        LinkedHashMap<Character, Integer> sortedMap = map.entrySet()
+                .stream()
+                .sorted(Map.Entry.<Character, Integer>comparingByValue().reversed()
+                        .thenComparing(Map.Entry.comparingByKey()))
+                .collect(Collectors.toMap(
+                        Map.Entry::getKey,
+                        Map.Entry::getValue,
+                        (e1, e2) -> e1,
+                        LinkedHashMap::new
+                ));
+        List<Map.Entry<Character, Integer>> entryList = new ArrayList<>(map.entrySet());
+        Collections.sort(entryList, (entry1, entry2) -> {
+            // 首先按照value倒序排序
+            int valueComparison = entry2.getValue().compareTo(entry1.getValue());
+
+            if (valueComparison != 0) {
+                return valueComparison;
+            } else {
+                // 如果value相同，按字典序升序排序
+                return entry1.getKey().compareTo(entry2.getKey());
+            }
+        });
+        // 第二种写法
+        /**
+         * LinkedHashMap<Character, Integer> sortedMap = map.entrySet()
+         *                 .stream()
+         *                 .sorted(Map.Entry.<Character, Integer>comparingByValue().reversed()
+         *                         .thenComparing(Map.Entry.comparingByKey()))
+         *                 .collect(Collectors.toMap(
+         *                         Map.Entry::getKey,
+         *                         Map.Entry::getValue,
+         *                         (e1, e2) -> e1,
+         *                         LinkedHashMap::new
+         *                 ));
+         */
+
+//        // 将排序后的结果重新放回LinkedHashMap
+//        LinkedHashMap<Character, Integer> sortedMap = entryList.stream()
+//                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));
+
+//        for (Map.Entry<Character, Integer> item : entryList) {
+//            stringBuffer
+//                    .append(item.getKey())
+//                    .append(item.getValue());
+//        }
+        for (Map.Entry<Character, Integer> item : sortedMap.entrySet()) {
+            stringBuffer
+                    .append(item.getKey())
+                    .append(item.getValue());
+        }
+
+        System.out.println(stringBuffer.toString());
+    }
+
+    public static String generateSummary(String inputString) {
+        // 去除字符串中的非字母符号
+        inputString = inputString.replaceAll("[^a-zA-Z]", "");
+
+        // 初始化结果列表
+        List<String> result = new ArrayList<>();
+
+        int i = 0;
+        while (i < inputString.length()) {
+            char currentChar = Character.toLowerCase(inputString.charAt(i));
+            int count = 1;
+
+            // 检查连续字符
+            while (i + 1 < inputString.length() && Character.toLowerCase(inputString.charAt(i + 1)) == currentChar) {
+                count++;
+                i++;
+            }
+
+            // 如果是连续字符，添加字符和次数
+            if (count > 1) {
+                result.add(currentChar + "" + count);
+            } else {
+                // 否则，查找字符之后的出现次数
+                String substring = inputString.substring(i + 1).toLowerCase();
+                int countAfter = substring.length() - substring.replace(currentChar + "", "").length();
+                result.add(currentChar + "" + countAfter);
+            }
+
+            i++;
+        }
+
+        // 使用自定义排序函数对结果进行排序
+        Collections.sort(result, (s1, s2) -> {
+            if (s1.substring(1).matches("\\d+") && s2.substring(1).matches("\\d+")) {
+                // 比较数字部分
+                int num1 = Integer.parseInt(s1.substring(1));
+                int num2 = Integer.parseInt(s2.substring(1));
+                if (num1 != num2) {
+                    return Integer.compare(num2, num1); // 降序排序
+                } else {
+                    // 如果数字相同，比较字母部分
+                    return Character.compare(s1.charAt(0), s2.charAt(0));
+                }
+            } else if (s1.substring(1).matches("\\d+")) {
+                return -1; // s1是数字，放在前面
+            } else if (s2.substring(1).matches("\\d+")) {
+                return 1; // s2是数字，放在前面
+            } else {
+                // 比较字母部分
+                return Character.compare(s1.charAt(0), s2.charAt(0));
+            }
+        });
+
+        // 将排序后的结果组合成最终字符串
+        StringBuilder summary = new StringBuilder();
+        for (String s : result) {
+            summary.append(s);
+        }
+
+        return summary.toString();
+    }
+
+    @Test
+    public void min() {
+        int[] m = {4, 2, 3, 1};
+        int cars = 10;
+        System.out.println(repairCars(m, cars));
+    }
+
+    /**
+     * 修车的最少时间
+     * RANK * N^2 = m  n = m / x
+     *
+     * @param ranks
+     * @param cars
+     * @return
+     */
+    public long repairCars(int[] ranks, int cars) {
+        long l = 1, r = 1L * ranks[0] * cars * cars;
+        while (l < r) {
+            long m = l + r >> 1;
+            if (check(ranks, cars, m)) {
+                r = m;
+            } else {
+                l = m + 1;
+            }
+        }
+        return l;
+    }
+
+    public boolean check(int[] ranks, int cars, long m) {
+        long cnt = 0;
+        for (int x : ranks) {
+            cnt += (long) Math.sqrt(m / x);
+        }
+        return cnt >= cars;
+    }
+
+    public boolean isValid(String str) {
+        StringBuffer stringBuffer = new StringBuffer();
+        for (char c : str.toCharArray()) {
+            if (isSymbol(c)) {
+                stringBuffer.append(c);
+            }
+        }
+        String s = stringBuffer.toString();
+        ArrayDeque<Character> stack = new ArrayDeque<>();
+        for (char c : s.toCharArray()) {
+            if ((c == ')' || c == ']' || c == '}') && !stack.isEmpty()) {
+                stack.pop();
+            } else {
+                stack.push(c);
+            }
+        }
+        return stack.isEmpty();
+    }
+
+    public boolean isSymbol(char c) {
+        if (c == '(' || c == '{' || c == '['
+                || c == ')' || c == ']' || c == '}') {
+            return true;
+        }
+        return false;
+    }
+
+    public static void main1(String[] args) {
+        Scanner scanner = new Scanner(System.in);
+        String s = scanner.nextLine();
+        int m = Integer.parseInt(s.split(" ")[0]);
+        int n = Integer.parseInt(s.split(" ")[1]);
+        int[][] array = new int[m][n];
+        int line = 0;
+        while (line < m) {
+            String item = scanner.nextLine();
+            String[] s1 = item.split(" ");
+            for (int i = 0; i < s1.length; i++) {
+                int ele = Integer.parseInt(s1[i]);
+                array[line][i] = ele;
+            }
+            // 表示矩阵；
+            line++;
+        }
+
+        log.info("{}", array);
+        System.out.println(maxArray(array));
+    }
+
+    @Test
+    public void testMatrix() {
+        int[][] matrix = {{-3, 5, -1, 5},
+                        {2, 4, -2, 4},
+                        {-1, 3, -1, 3}};
+        maxArray(matrix);
+
+    }
+
+    /**
+     * ---**--|--**---|--------------------
+     * **  |  (i,j)   |
+     * -----|-----|--------------------
+     *
+     * @param matrix
+     * @return
+     */
+    public static int[] maxArray(int[][] matrix) {
+        int n = matrix.length, m = matrix[0].length;
+        //二维前缀和
+        int[][] preSum = new int[n + 1][m + 1];
+        for (int i = 1; i < n + 1; i++) {
+            for (int j = 1; j < m + 1; j++) {
+                // 为什么要这么用呢？ 对角的用原来的；首先要清楚他的定义是什么？
+                preSum[i][j] = matrix[i - 1][j - 1] + preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1];
+            }
+        }
+        //开始最大子序和global
+        int global = Integer.MIN_VALUE;
+        int[] ret = new int[4];
+        //先固定上下两条边
+        for (int top = 0; top < n; top++) {
+            for (int bottom = top; bottom < n; bottom++) {
+                int localMax = 0, left = 0;
+                //然后从左往右一遍扫描找最大子序和
+                for (int right = 0; right < m; right++) {
+                    //利用presum快速求出localMax
+                    localMax = preSum[bottom + 1][right + 1] + preSum[top][left] - preSum[bottom + 1][left] - preSum[top][right + 1];
+                    //如果比 gobal大，更新
+                    if (global < localMax) {
+                        global = localMax;
+                        //记录下坐标位置！！
+                        ret[0] = top;
+                        ret[1] = left;
+                        ret[2] = bottom;
+                        ret[3] = right;
+                    }
+                    //如果不满0，前面都舍弃，从新开始计算，left更新到right+1，right下一轮递增之后left==right
+                    if (localMax < 0) {
+                        localMax = 0;
+                        left = right + 1;
+                    }
+                }
+            }
+        }
+        return ret;
+    }
+
+    public static int findMinMoveDistance(int[] heights) {
+        int n = heights.length;
+        int[][] dp = new int[n][2]; // dp[i][0]表示以"高"开头的最小移动距离，dp[i][1]表示以"矮"开头的最小移动距离
+
+        dp[0][0] = 0; // 以"高"开头的第一个位置不需要移动
+        dp[0][1] = 0; // 以"矮"开头的第一个位置不需要移动
+
+        for (int i = 1; i < n; i++) {
+            if (i % 2 == 0) {
+                // 当前位置要求是"高"，前一个位置必须是"矮"
+                dp[i][0] = dp[i - 1][0];
+                dp[i][1] = dp[i - 1][1] + 1;
+            } else {
+                // 当前位置要求是"矮"，前一个位置必须是"高"
+                dp[i][0] = dp[i - 1][0] + 1;
+                dp[i][1] = dp[i - 1][1];
+            }
+        }
+
+        // 最小移动距离为以"高"或"矮"开头的最小移动距离中的较小值
+        return Math.min(dp[n - 1][0], dp[n - 1][1]);
+    }
+
+    @Test
+    public void minHeight() {
+        int[] arr = {4, 3, 5, 7, 8};
+        log.info("{}", findMinMoveDistance(arr));
+    }
+
+    public static void main3(String[] args) {
+        Scanner scanner = new Scanner(System.in);
+        int m = Integer.parseInt(scanner.nextLine());
+        if (m <= 1 || m >= 100){
+            System.out.println("ERROR");
+            return;
+        }
+        System.out.println(yuesefu(100, 3));
+    }
+
+    public static Object[] josfer(int m) {
+        boolean[] used = new boolean[100];
+        int count = 100, index = 0;
+        while (count >= m) {
+            int cnt = 0;
+            while (cnt < m-1) {
+                if (!used[index]) {
+                    cnt++;
+                }
+                if (cnt < m) {
+                    index = (index+1)%100;
+                }
+            }
+            used[index] = true;
+            count--;
+            while (used[index]) {
+                index = (index+1)%100;
+            }
+        }
+        ArrayList<Integer> integers = new ArrayList<>();
+        for (int i = 0; i < used.length; i++) {
+            if (!used[i]) {
+                integers.add(i);
+            }
+        }
+        return integers.toArray();
+    }
+
+    public static List<Integer> yuesefu(int totalNum, int countNum) {
+        // 初始化人数
+        List<Integer> start = new ArrayList<Integer>();
+        ArrayList<Integer> res = new ArrayList<>();
+        for (int i = 1; i <= totalNum; i++) {
+            start.add(i);
+        }
+        // 从索引0开始计数
+        int i = 0;
+        while (start.size() > 0) {
+            //从0位置计算第三个元素位置在哪里
+            i = i + countNum - 1;
+            // 通过取模与运维获得下一个索引位置在哪里，避免索引越界
+            i = i % (start.size());
+            // 判断是否只剩下二个
+            if (start.size() < countNum) {
+                res.addAll(start);
+//                System.out.println("start= " + start);
+                break;
+            } else {
+                start.remove(i);
+            }
+        }
+        return res;
+    }
+
+    public static int[] findSurvivor(int n, int k) {
+
+        boolean[] people = new boolean[n]; // 使用布尔数组表示每个人是否还在圈内
+        for (int i = 0; i < n; i++) {
+            people[i] = true; // 初始化所有人都在圈内
+        }
+
+        int count = 0; // 记录出圈的人数
+        int index = 0; // 当前报数的人的索引
+
+        while (count < n - k + 1) { // 循环直到只剩下一个人
+            int step = 0; // 记录报数的步数
+
+            while (step < k) {
+                if (people[index]) { // 如果当前位置的人还没有出圈
+                    step++;
+                }
+                if (step < k) {
+                    index = (index + 1) % n; // 移动到下一个人
+                }
+            }
+
+            // 找到要出圈的人，标记为已出圈
+            people[index] = false;
+            count++;
+
+            // 移动到下一个还没出圈的人
+            while (!people[index]) {
+                index = (index + 1) % n;
+            }
+        }
+        List<Integer> res = new ArrayList<>();
+        // 找到最后剩下的人的编号
+        for (int i = 0; i < n; i++) {
+            if (people[i]) {
+                res.add(i + 1); // 编号是从1开始的
+            }
+        }
+
+        return res.stream().mapToInt(m->m).toArray(); // 出错时返回-1
+    }
+
+    @Test
+    public void testSwap() {
+        int a  = 100;
+        int b = 3;
+        System.out.println(Arrays.toString(findSurvivor(a, b)));
+    }
+
+    /**
+     * 跳个子最大的分数
+     *
+     * @param arr
+     * @param n
+     * @return
+     */
+    public int solveI(int[] arr,int n) {
+        int[] dp = new int[n];
+        dp = arr;
+        /**
+         * 初始的状态是原来的分数
+         * 转移的方程是
+         * dp[i] = dp(i-2) + arr[i];
+         *
+         */
+        for (int i = 0; i < n; i++) {
+            if (i -  2 >= 0) {
+                dp[i] = dp[i-2] + arr[i];
+            }
+        }
+        log.info("{}", dp);
+        return Arrays.stream(dp).max().getAsInt();
+    }
+
+    @Test
+    public void testJumpI() {
+//        int[] arr = {1,2,3,1};
+        int[] arr = {2,7,9,3,1};
+        System.out.println(solveIS(arr, 5));
+    }
+
+    public int solveIS(int[] nums, int n) {
+        if (n <= 2) {
+            // 如果格子数量小于等于2，直接返回最大的分数
+            return n == 1 ? nums[0] : Math.max(nums[0], nums[1]);
+        }
+
+        int[] dp = new int[n];
+        dp[0] = nums[0]; // 第一个格子的得分就是它本身
+        dp[1] = Math.max(nums[0], nums[1]); // 第二个格子的得分是两个格子中的较大分数
+
+        for (int i = 2; i < n; i++) {
+            // 对于每个格子，有两种选择：跳过它或者跳到它
+            // 如果跳过它，得分等于前一个格子的得分
+            // 如果跳到它，得分等于前两个格子的得分加上当前格子的分数
+            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
+        }
+
+        return dp[n - 1];
+    }
+
+    /**
+     * 最大的
+     *
+     * @param nums
+     * @param n
+     * @return
+     */
+    public int solveJumpII(int[] nums, int n) {
+        return n;
+    }
+
+    public int maxHandle() {
+        return 0;
+    }
+
+    @Test
+    public void testHandle() {
+//        String s = "128";
+//        int i = Integer.parseInt(s, 2);
+//        System.out.println(i);
+//        int i = 128<<24 + 255 << 8 + 255;
+        String res = convertToDec(new long[]{128L, 0L, 255L, 255L});
+        System.out.println(res);
+        String s = Long.toHexString(Long.parseLong(res));
+        System.out.println("ox"+s.toUpperCase());
+    }
+
+    private static String convertToDec(long[] ipParts) {
+        long result = (ipParts[0] << 24) | (ipParts[1] << 16) | (ipParts[2] << 8) | ipParts[3];
+        return result+"";
+    }
+
+    public static boolean isValidIp(String[] strings) {
+        int first = Integer.parseInt(strings[0]);
+        int second = Integer.parseInt(strings[1]);
+        int third = Integer.parseInt(strings[2]);
+        int four = Integer.parseInt(strings[3]);
+        if (isBetween(first, second, third, four)) {
+            return true;
+        }
+        return false;
+    }
+
+    public static boolean isBetween(int first, int second, int third, int four) {
+        return (first>= 1 && first <= 128) && isBetween255(second)
+                && isBetween255(third) && isBetween255(four);
+    }
+
+    private static boolean isBetween255(int third) {
+        return third>=1 && third<=255;
+    }
+
+    // 前k个最小值？
+
+    // 第三大的数
+    public int thirdMax(int[] nums) {
+        int third = Integer.MIN_VALUE;
+        for (int num : nums) {
+
+        }
+        return third;
+    }
+
+    /**
+     * 2个字符必须要马努01.要是不满足。判断是否第一个为0;1)是加入。2）不加入；
+     *
+     * @param s
+     * @return
+     */
+    public int maxLengthOfPattern(String s) {
+        if (s.length() < 3 || s.length() > 1024) {
+            return -1;
+        }
+        // 判断是否有010
+        if (!s.contains("010")) {
+            return -1;
+        }
+        // 把01作为一个整体来进行处理，有的是
+        return -1;
+    }
+
+    /**
+     * 一个数字，多个字母；
+     *
+     * @param s
+     * @return
+     */
+    public int maxLengthOfSpecial(String s) {
+        if (s == null || s.length() == 0) {
+            return -1;
+        }
+        String patternDigit = "\\d+";
+        String patternChar = "\\w+";
+        Pattern compile = Pattern.compile(patternChar);
+        Pattern compileDigit = Pattern.compile(patternDigit);
+        if (compile.matcher(s).find() ||  compileDigit.matcher(s).find()) {
+            return -1;
+        }
+        // 处理逻辑。需要有什么呢？
+        int left = 0, right = 0, max = Integer.MIN_VALUE;
+        while (right < s.length()) {
+            while (right < s.length() && isChar(s.charAt(right)) &&
+                    isChar(s.charAt(right))) {
+                right++;
+            }
+            left = right;
+
+        }
+
+        return 4;
+    }
+
+    public boolean isChar(char c) {
+        return (c >= 'a' && c <= 'z') || (c <= 'Z' && c >= 'A');
+    }
+
+    @Test
+    public void testChar() {
+//        System.out.println(findLongestSubstring("111ab"));
+    }
+
+    //其实就是滑动的窗口，要获取到所有的值呢？
+
+    /**
+     * 最小 --> 最大的
+     *
+     * @return
+     */
+    public int maxWindow() {
+        return 0;
+    }
+
+    // 全排列；
+    // 高矮个子的排列。
+
+    public static void main(String[] args) {
+        Scanner scanner = new Scanner(System.in);
+        String line = scanner.nextLine();
+
+        int len = maxLengthWith(line);
+        System.out.println(len);
+    }
+
+    /**
+     *1、 只包含1个字母(a~z, A~Z)，其余必须是数字；
+     *2、 字母可以在子串中的任意位置；
+     *
+     * @param line
+     * @return
+     */
+    public static int maxLengthWith(String line) {
+        char[] chars = line.toCharArray();
+
+        ArrayList<Integer> integers = new ArrayList<>();
+        // 关键点：第一个初始值，防止出现只有一个字母或者没有字母，无法进入循环的情况
+        integers.add(-1);
+        for (int i = 0; i < chars.length; i++) {
+            char aChar = chars[i];
+            if ((65 <= aChar && aChar <= 90) || (97 <= aChar && aChar <= 122)) {
+                integers.add(i); // 存放所有字母出现的索引值
+            }
+        }
+        // 关键点：第一个初始值，防止出现只有一个字母或者没有字母，无法进入循环的情况
+        integers.add(chars.length);
+
+        int len = -1;
+        for (int i = 0; i < integers.size() - 2; i++) {
+            int temp = integers.get(i + 2) - integers.get(i); // 每隔一个字母差值，即可判断可以放多少个数字
+            // 这里的意思是最少是要存放一个一个数字的。
+            if (temp > 2) {
+                // 这里要去除一个字母的。仅仅保留一个字母
+                if (temp - 1 > len) {
+                    len = temp - 1; // 出现更长的长度时才替换
+                }
+            }
+        }
+        return len;
+    }
+
+    @Test
+    public void testLen() {
+        String s = "abcdef";
+        String s1 = "111av";
+        String s2 = "sss";
+        System.out.println(maxLengthWith(s2));
+    }
+
+    public static void salu(int[] nums) {
+        for (int i = 0; i < nums.length - 1; i++) {
+            if (i % 2 == 0 && nums[i] < nums[i + 1]) {
+                //如果位置是高位置，但下一个位置大于当前位置，替换
+                int tmp = nums[i];
+                nums[i] = nums[i + 1];
+                nums[i + 1] = tmp;
+            }
+            if (i % 2 == 1 && nums[i] > nums[i + 1]) {
+                //如果位置是矮位置，但下一个位置小于当前位置，替换
+                int tmp = nums[i];
+                nums[i] = nums[i + 1];
+                nums[i + 1] = tmp;
+            }
+        }
+    }
+}
Index: common/core/src/main/java/org/example/common/core/design/Faceor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/design/Faceor.java b/common/core/src/main/java/org/example/common/core/design/Faceor.java
new file mode 100644
--- /dev/null	(date 1698633783343)
+++ b/common/core/src/main/java/org/example/common/core/design/Faceor.java	(date 1698633783343)
@@ -0,0 +1,92 @@
+package org.example.common.core.design;
+
+import org.junit.Test;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description: 门面模式。对多个小功能的封装处理。
+ * Spring MVC框架：Spring MVC的DispatcherServlet可以看作是一个门面，它隐藏了底层的Servlet容器和HTTP请求处理的复杂性。它将请求分发给控制器，使开发人员可以更专注于处理业务逻辑。
+ *
+ * Spring JDBC框架：Spring的JdbcTemplate类是对JDBC的一个门面，它简化了与数据库的交互，隐藏了许多繁琐的JDBC代码，如连接管理、异常处理等。
+ *
+ * Spring事务管理：Spring的事务管理也使用门面模式。PlatformTransactionManager是一个接口，它提供了一个通用的事务管理接口，隐藏了不同事务管理器的具体实现细节，如JDBC事务、JTA事务等。
+ *
+ * Spring Security：Spring Security框架提供了一组门面，用于处理身份验证和授权。它隐藏了底层的安全机制的复杂性，使应用程序更容易实现安全性。
+ *
+ * Spring Boot：Spring Boot是Spring的一个子项目，它提供了一个快速构建应用程序的方式。Spring Boot的自动配置和起步依赖可以看作是门面，它们隐藏了大量的配置和依赖管理，使开发人员更容易创建Spring应用程序。
+ *
+ * 这些示例中，Spring框架提供了门面，用于封装底层复杂性，使开发人员能够更方便地使用Spring的各种功能，同时提高了代码的可维护性和可读性。
+ * @time: 2023/9/2 16:18
+ */
+public class Faceor {
+    // 子系统组件类
+    class Projector {
+        public void turnOn() {
+            System.out.println("投影仪已开启");
+        }
+
+        public void turnOff() {
+            System.out.println("投影仪已关闭");
+        }
+    }
+
+    class SoundSystem {
+        public void turnOn() {
+            System.out.println("音响已开启");
+        }
+
+        public void turnOff() {
+            System.out.println("音响已关闭");
+        }
+    }
+
+    class DVDPlayer {
+        public void turnOn() {
+            System.out.println("DVD播放器已开启");
+        }
+
+        public void turnOff() {
+            System.out.println("DVD播放器已关闭");
+        }
+    }
+
+    // 家庭影院门面类
+    class HomeTheaterFacade {
+        private Projector projector;
+        private SoundSystem soundSystem;
+        private DVDPlayer dvdPlayer;
+
+        public HomeTheaterFacade() {
+            projector = new Projector();
+            soundSystem = new SoundSystem();
+            dvdPlayer = new DVDPlayer();
+        }
+
+        public void watchMovie() {
+            System.out.println("准备观看电影...");
+            projector.turnOn();
+            soundSystem.turnOn();
+            dvdPlayer.turnOn();
+        }
+
+        public void endMovie() {
+            System.out.println("电影结束...");
+            projector.turnOff();
+            soundSystem.turnOff();
+            dvdPlayer.turnOff();
+        }
+    }
+
+    @Test
+    public void main() {
+        // 创建家庭影院门面对象
+        HomeTheaterFacade homeTheater = new HomeTheaterFacade();
+
+        // 用户只需与门面类交互，而无需了解内部组件的复杂性
+        homeTheater.watchMovie();
+        System.out.println("---------------");
+        homeTheater.endMovie();
+    }
+
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/algorithm/Leet150.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/algorithm/Leet150.java b/common/core/src/main/java/org/example/common/core/leetcode/algorithm/Leet150.java
new file mode 100644
--- /dev/null	(date 1698633783363)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/algorithm/Leet150.java	(date 1698633783363)
@@ -0,0 +1,169 @@
+package org.example.common.core.leetcode.algorithm;
+
+import lombok.extern.slf4j.Slf4j;
+import org.junit.Test;
+import org.springframework.stereotype.Service;
+
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.HashSet;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/9/7 17:24
+ */
+@Slf4j
+public class Leet150 {
+    /**
+     * 获取最长的连续子序列,因为不要求那个下标。
+     *
+     * @param nums
+     * @return
+     */
+    public int longestConsecutive(int[] nums) {
+        // 转化成哈希集合，方便快速查找是否存在某个元素
+        HashSet<Integer> set = new HashSet<Integer>();
+        for (int num : nums) {
+            set.add(num);
+        }
+
+        int res = 0;
+
+        for (int num : set) {
+            if (set.contains(num - 1)) {
+                // num 不是连续子序列的第一个，跳过
+                continue;
+            }
+            // num 是连续子序列的第一个，开始向上计算连续子序列的长度
+            int curNum = num;
+            int curLen = 1;
+
+            while (set.contains(curNum + 1)) {
+                curNum += 1;
+                curLen += 1;
+            }
+            // 更新最长连续序列的长度
+            res = Math.max(res, curLen);
+        }
+
+        return res;
+    }
+
+    /**
+     * 最少数量的箭引爆气球。就是找出有交集的个数。
+     *
+     * @param points
+     * @return
+     */
+    public int findMinArrowShots(int[][] points) {
+        int count = 1;
+        int len = points.length;
+        Arrays.sort(points, (Comparator.comparingInt(o -> o[1])));
+        int end = points[0][1];
+        for (int i = 0; i < len; i++) {
+            int start = points[i][0];
+            // 只有大于的时候才要加起来的。要不然就不要处理了。
+            if (start > end) {
+                end = points[i][1];
+                count++;
+            }
+        }
+        return count;
+    }
+
+    @Test
+    public void mainShe() {
+        int[][] ints = {{10, 16}, {2, 8}, {1, 6}, {7, 12}};
+        System.out.println(findMinArrowShots(ints));
+        final boolean interrupted = Thread.interrupted();
+    }
+
+    /**
+     * 3,5,7所有的1~n
+     *
+     * <p>
+     * 3 6 9
+     * 5 10 15
+     * 7 14 21 28 ...
+     * </p>
+     *
+     * @param n
+     * @return
+     */
+    public int sumOfMultiples(int n) {
+        if (n < 3) {
+            return 0;
+        }
+        return sumOfMultiplesSolution(n);
+    }
+
+    /**
+     * 为什么正向的就错了？有公共的公约，没有办法做到一次处理！
+     *
+     * @param n
+     * @return
+     */
+    public int sumOfMultiplesSolution(int n) {
+        int constant3 = 3, constant5 = 5, constant7 = 7;
+        int sum = 0;
+        int step = 1;
+        int tempConstant3 = 0, tempConstant5 = 0, tempConstant7 = 0;
+        while (tempConstant3 <= n || tempConstant5 <= n || tempConstant7 <= n) {
+
+            tempConstant3 = step * constant3;
+            tempConstant5 = step * constant5;
+            tempConstant7 = step * constant7;
+            step++;
+            StringBuilder stringBuilder = new StringBuilder();
+            if (tempConstant3 <= n) {
+                stringBuilder.append(tempConstant3);
+                sum += tempConstant3;
+            }
+
+            if (tempConstant5 <= n) {
+                stringBuilder.append("\t"+tempConstant5);
+                sum += tempConstant5;
+            }
+
+            if (tempConstant7 <= n) {
+                stringBuilder.append("\t"+tempConstant7);
+                sum += tempConstant7;
+            }
+            log.info("{}", stringBuilder.toString());
+            stringBuilder.setLength(0);
+        }
+
+        return sum;
+    }
+
+    @Test
+    public void mainSum() {
+        int n = 15;
+        /**
+         * 3
+         * 5
+         * 6
+         * 7
+         * 9
+         * 10
+         * 12
+         * 14
+         * 15
+         */
+        System.out.println(sumOfMultiples(n));
+    }
+
+    public int sumOfMultiplesBeautify(int n) {
+        int res = 0;
+        for (int i = 1; i <= n; i++) {
+            if (i % 3 == 0 || i % 5 == 0 || i % 7 == 0) {
+                log.info("{}", i);
+                res += i;
+            }
+
+        }
+        return res;
+    }
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/algorithm/MergeSort.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/algorithm/MergeSort.java b/common/core/src/main/java/org/example/common/core/leetcode/algorithm/MergeSort.java
new file mode 100644
--- /dev/null	(date 1698633783367)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/algorithm/MergeSort.java	(date 1698633783367)
@@ -0,0 +1,218 @@
+package org.example.common.core.leetcode.algorithm;
+
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:归并排序的应用
+ * @time: 2023/9/3 14:35
+ */
+public class MergeSort {
+    /**
+     * 合并2个数组，利用的是归并排序。
+     *
+     * @param nums1
+     * @param m
+     * @param nums2
+     * @param n
+     */
+    public void merge(int[] nums1, int m, int[] nums2, int n) {
+        int len = m + n;
+        int[] temp = new int[len];
+        mergeTwoArray(nums1, nums2, temp);
+    }
+
+    public void mergeTwoArray(int[] left, int[] right, int[] temp) {
+        int rP = 0, lP = 0, index = 0;
+        while (rP < right.length && lP < left.length) {
+            if (left[lP] < right[rP]) {
+                temp[index++] = left[lP];
+                lP++;
+            } else {
+                temp[index++] = right[rP];
+                rP++;
+            }
+        }
+        // 还会遗漏下右边或者左边的数据。
+        if (rP >= right.length) {
+
+        }
+
+        if (lP >= left.length) {
+
+        }
+    }
+
+    /**
+     * <p>
+     * 对于单链表来说，我们直接用双指针从头开始合并即可，但对于数组来说会出问题。因为题目让我直接把结果存到 nums1 中，
+     * 而 nums1 的开头有元素，如果我们无脑复制单链表的逻辑，会覆盖掉 nums1 的原始元素，导致错误。
+     * <p>
+     * 但 nums1 后面是空的呀，所以这道题需要我们稍微变通一下：将双指针初始化在数组的尾部，然后从后向前进行合并，
+     * 这样即便覆盖了 nums1 中的元素，这些元素也必然早就被用过了，不会影响答案的正确性。
+     * </p>
+     *
+     * @param nums1
+     * @param m
+     * @param nums2
+     * @param n
+     */
+    public void mergeSolution(int[] nums1, int m, int[] nums2, int n) {
+        // 两个指针分别初始化在两个数组的最后一个元素（类似拉链两端的锯齿）
+        int i = m - 1, j = n - 1;
+        // 生成排序的结果（类似拉链的拉锁）
+        int p = nums1.length - 1;
+        // 从后向前生成结果数组，类似合并两个有序链表的逻辑
+        while (i >= 0 && j >= 0) {
+            if (nums1[i] > nums2[j]) {
+                nums1[p] = nums1[i];
+                i--;
+            } else {
+                nums1[p] = nums2[j];
+                j--;
+            }
+            p--;
+        }
+        // 可能其中一个数组的指针走到尽头了，而另一个还没走完
+        // 因为我们本身就是在往 nums1 中放元素，所以只需考虑 nums2 是否剩元素即可
+        while (j >= 0) {
+            nums1[p] = nums2[j];
+            j--;
+            p--;
+        }
+    }
+
+    @Test
+    public void main() {
+        int[] a = {1,2,3,0,0,0};
+        int[] b = {2,5,6};
+        int m = 3, n = 3;
+        mergeSolution(a, m, b, n);
+    }
+
+    /**
+     * 相同的元素要被保留一份
+     *
+     * @param nums
+     * @return
+     */
+    public int removeDuplicates(int[] nums) {
+        int n = nums.length;
+        List<Integer> list = new ArrayList<>();
+        for (int i = 0; i <= n-1; i++) {
+            if (i < n-1 && nums[i] == nums[i+1]) {
+                while (nums[i] == nums[i + 1]) {
+                    if (!list.contains(nums[i])) {
+                        list.add(nums[i]);
+                    }
+                    // 储存一份；
+                    i++;
+                }
+            } else {
+                list.add(nums[i]);
+            }
+        }
+        return list.size();
+    }
+
+    @Test
+    public void saveOneTest() {
+        int[] nums = {0,0,1,1,1,2,2,3,3,4};
+        removeDuplicatesSol(nums);
+    }
+
+    public int removeDuplicatesSol(int[] nums) {
+        if(nums == null || nums.length == 0) {
+            return 0;
+        }
+        int p = 0;
+        int q = 1;
+        while(q < nums.length){
+            if(nums[p] != nums[q]){
+                nums[p + 1] = nums[q];
+                p++;
+            }
+            q++;
+        }
+        return p + 1;
+    }
+
+    public int removeDuplication(int[] nums) {
+        int index = 0;
+        for (int i = 0; i < nums.length; i++) {
+            // 满足此条件才会加入
+//            if (nums[i] == nums[i+1] && i+1 <  nums.length) {
+//                int x = nums[i];
+//                while (nums[i++] == x && count <2) {
+//                    count++;
+//                    nums[index++] = nums[i];
+//                }
+//                count = 0;
+//            } else {
+//                nums[index++] = Integer.MIN_VALUE;
+//            }
+
+        }
+        // nums要进行处理。不要后面的元素了。其实会有的情况是在范围内就代表了是重复的nums[n-k] != nums[n];
+
+        return index;
+    }
+
+    @Test
+    public void testDuplication() {
+        int[] nums = {1,1,1,2,2,3};
+        removeDuplicatesII(nums);
+    }
+
+    public int removeDuplicatesII(int[] nums) {
+        int n = nums.length;
+        if (n <= 2) {
+            return n;
+        }
+        int slow = 2, fast = 2;
+        while (fast < n) {
+            if (nums[slow - 2] != nums[fast]) {
+                nums[slow] = nums[fast];
+                ++slow;
+            }
+            ++fast;
+        }
+        return slow;
+    }
+
+    public int majorityElement(int[] nums) {
+        // 我们想寻找的那个众数
+        int target = 0;
+        // 计数器（类比带电粒子例子中的带电性）
+        int count = 0;
+        for (int i = 0; i < nums.length; i++) {
+            // 这里设计的太巧妙了。太厉害了。
+            if (count == 0) {
+                // 当计数器为 0 时，假设 nums[i] 就是众数
+                target = nums[i];
+                // 众数出现了一次
+                count = 1;
+            } else if (nums[i] == target) {
+                // 如果遇到的是目标众数，计数器累加
+                count++;
+            } else {
+                // 如果遇到的不是目标众数，计数器递减
+                count--;
+            }
+        }
+        // 回想带电粒子的例子
+        // 此时的 count 必然大于 0，此时的 target 必然就是目标众数
+        return target;
+    }
+
+    @Test
+    public void testMajor() {
+        int[] nums = {3,3,4};
+        System.out.println(majorityElement(nums));
+    }
+
+}
Index: common/web/src/main/java/org/example/web/socket/TCPTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/web/src/main/java/org/example/web/socket/TCPTest.java b/common/web/src/main/java/org/example/web/socket/TCPTest.java
new file mode 100644
--- /dev/null	(date 1698633783462)
+++ b/common/web/src/main/java/org/example/web/socket/TCPTest.java	(date 1698633783462)
@@ -0,0 +1,45 @@
+package org.example.web.socket;
+
+import lombok.extern.slf4j.Slf4j;
+
+import java.io.IOException;
+import java.net.ServerSocket;
+import java.net.Socket;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/9/28 10:08
+ */
+@Slf4j
+public class TCPTest {
+    public static void main(String[] args) throws IOException {
+        final ServerSocket serverSocket = new ServerSocket(2000);
+        System.out.println(serverSocket.getInetAddress() + " Port: " + serverSocket.getLocalPort());
+
+        // 等待客户端的连接
+        final Socket accept = serverSocket.accept();
+        // TODO: 2023/9/28
+        serverSocket.close();
+        System.out.println("服务端已经关闭了");
+
+    }
+
+    public static class ClientHolder extends Thread {
+
+        @Override
+        public void run() {
+            super.run();
+            System.out.println("客户端连接");
+
+            try {
+
+            } catch (Exception e) {
+                log.info("客户端失败。");
+            } finally {
+                // 关闭资源
+            }
+        }
+    }
+}
Index: common/core/pom.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <parent>\r\n        <artifactId>common</artifactId>\r\n        <groupId>org.example</groupId>\r\n        <version>1.0-SNAPSHOT</version>\r\n    </parent>\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <artifactId>core</artifactId>\r\n\r\n    <properties>\r\n        <maven.compiler.source>8</maven.compiler.source>\r\n        <maven.compiler.target>8</maven.compiler.target>\r\n    </properties>\r\n\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>com.fasterxml.jackson.core</groupId>\r\n            <artifactId>jackson-databind</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>com.fasterxml.jackson.core</groupId>\r\n            <artifactId>jackson-core</artifactId>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>com.baomidou</groupId>\r\n            <artifactId>mybatis-plus-boot-starter</artifactId>\r\n        </dependency>\r\n    </dependencies>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/pom.xml b/common/core/pom.xml
--- a/common/core/pom.xml	(revision cf8ea38fa9da362ec8a79646980a64be2e30bae6)
+++ b/common/core/pom.xml	(date 1698896705217)
@@ -30,5 +30,15 @@
             <groupId>com.baomidou</groupId>
             <artifactId>mybatis-plus-boot-starter</artifactId>
         </dependency>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <version>4.13.2</version>
+            <scope>compile</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.openjdk.jol</groupId>
+            <artifactId>jol-core</artifactId>
+        </dependency>
     </dependencies>
 </project>
\ No newline at end of file
Index: common/core/src/main/java/org/example/common/core/leetcode/algorithm/Maoao.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/algorithm/Maoao.java b/common/core/src/main/java/org/example/common/core/leetcode/algorithm/Maoao.java
new file mode 100644
--- /dev/null	(date 1698635984124)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/algorithm/Maoao.java	(date 1698635984124)
@@ -0,0 +1,387 @@
+package org.example.common.core.leetcode.algorithm;
+
+import lombok.extern.slf4j.Slf4j;
+import org.junit.Test;
+
+import java.util.Arrays;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/8/20 18:07
+ */
+@Slf4j
+public class Maoao {
+    public void bubbleSort(int[] arr) {
+        if (arr == null) {
+            return;
+        }
+        int len = arr.length;
+        for (int i = 0; i < len - 1; i++) {
+            for (int j = 0; j < len - i - 1; j++) {
+                if (arr[j] > arr[j + 1]) {
+                    // 交换位置
+                    int temp = arr[j];
+                    arr[j] = arr[j + 1];
+                    arr[j + 1] = temp;
+                }
+            }
+        }
+    }
+
+    public void quickSort(int[] arr, int start, int end) {
+        if (start < end) {
+            int s = arr[start];
+            int low = start, high = end;
+            while (low < high) {
+                // 寻找小的
+                while (low < high && arr[high] >= s) {
+                    high--;
+                }
+                arr[low] = arr[high];
+                // 寻找大的！
+                while (low < high && arr[low] < s) {
+                    low++;
+                }
+                arr[high] = arr[low];
+            }
+            arr[low] = s;
+            quickSort(arr, start, low);
+            quickSort(arr, low + 1, end);
+        }
+    }
+
+    @Test
+    public void test() {
+        int[] arr = {1, 5, 4, 3};
+        quickSort(arr, 0, 3);
+        System.out.println(Arrays.toString(arr));
+    }
+
+    // 插入排序、选择排序是什么呢？
+    public void insertSort(int[] arr) {
+        int len = arr.length;
+        for (int i = 1; i <= len - 1; i++) {
+            // 对比的是比i小的数据
+            if (arr[i] < arr[i - 1]) {
+                int j;
+                int temp = arr[i];
+                for (j = i - 1; j >= 0; j--) {
+                    arr[j + 1] = arr[j];
+                }
+                arr[j + 1] = temp;
+            }
+        }
+    }
+
+    public int search(int[] arr, int target) {
+        if (arr[0] == target) {
+            return 0;
+        }
+        int right = arr.length - 1;
+        int left = 0;
+        int mid = 0;
+        while (left < right) {
+            mid = left + (right - left) / 2;
+            if (arr[mid] == target) {
+                while (mid > 0 && arr[mid - 1] == arr[mid]) {
+                    mid--;
+                }
+                return mid;
+            }
+            // 0~mid 递增 mid ~ right递增
+            if (arr[mid] < arr[right]) {
+                if (arr[mid] < target && target <= arr[right]) {
+                    left = mid+1;
+                } else {
+                    right = mid - 1;
+                }
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * 删除有序数组中的重复项 II 所有的元素只出现2次
+     *
+     * @param nums
+     * @return
+     */
+    public int removeDuplicates(int[] nums) {
+
+        int left = 0, right = 0, count = 0;
+        int len = nums.length;
+        while (right < len) {
+            while (nums[left] == nums[right]) {
+                count++;
+                if (count > 2) {
+                    nums[right] = Integer.MIN_VALUE;
+                }
+                right++;
+            }
+            count = 0;
+            if (nums[left] < nums[right]) {
+                left = right++;
+            }
+        }
+        System.out.println(Arrays.toString(nums));
+        Long count1 = Arrays.stream(nums).filter(m -> m != Integer.MIN_VALUE).count();
+        return count1.intValue();
+    }
+
+    /**
+     * 输入: nums = [1,2,3,4,5,6,7], k = 3
+     * 输出: [5,6,7,1,2,3,4]
+     *
+     * @param nums
+     * @param k
+     */
+    public void rotate(int[] nums, int k) {
+        int len = nums.length;
+        int[] newArr = new int[len];
+        for (int i = 0; i < len; i++) {
+            int rotateIndex = (i + k) % len;
+            newArr[rotateIndex] = nums[i];
+        }
+        System.out.println(Arrays.toString(newArr));
+    }
+
+    @Test
+    public void roTest() {
+        int[] ro = {1,2,3,4,6,7,5};
+        System.out.println(findKthMaxNum(ro, 3));
+        log.info("{}", ro);
+    }
+
+
+    public int findKthMaxNum(int[] nums, int k) {
+        int n = nums.length;
+        return quickSortSelect(nums, 0, n-1, n-k);
+    }
+
+    //  注意下标的表示方法。
+    private int quickSortSelect(int[] nums, int l, int r, int k) {
+        if (l == r) {
+            return nums[k];
+        }
+        int x = nums[l], i = l - 1, j = r+1;
+        while (i < j) {
+            do {
+                i++;
+            }
+            while (nums[i] < x);
+            do {
+                j--;
+            }
+            while (nums[j] > x);
+            if (i < j) {
+                int tmp = nums[i];
+                nums[i] = nums[j];
+                nums[j] = tmp;
+            }
+        }
+        if (k <= j) {
+            return quickSortSelect(nums, l, j, k);
+        } else {
+            return quickSortSelect(nums, j + 1, r, k);
+        }
+    }
+    
+    /**
+     * 1组成的最大的面积
+     * <p>
+     *     特点是：
+     *     左右搜索，最长的长度。Square = Min(len, width)^2
+     *     广度搜索算法
+     * </p>
+     * 
+     * @param matrix
+     * @return
+     */
+    public int maximalSquare(char[][] matrix) {
+        if (matrix == null) {
+            return 0;
+        }
+        int l = matrix.length;
+        int w = matrix[0].length;
+        int sq = 0;
+        for (int i = 0; i < l; i++) {
+            for (int j = 0; j < w; j++) {
+                int LENGTH = 0, WIDTH = 0;
+                if (matrix[i][j] == '1') {
+                    dfs(matrix, LENGTH, WIDTH, i, j);
+                }
+                // 比较最大值。
+            }
+        }
+        return sq;
+    }
+
+    private void dfs(char[][] matrix, int length, int width, int wi, int li) {
+        if (matrix[wi][li] == '0' || matrix[++wi][li] == '0'
+                ||matrix[wi][++li] == '0') {
+            return;
+        }
+        int l = matrix.length;
+        int w = matrix[0].length;
+        // 什么时候，触发呢？
+    }
+
+    public int maximalSquareSolution(char[][] matrix) {
+        int maxSide = 0;
+        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
+            return maxSide;
+        }
+        int rows = matrix.length, columns = matrix[0].length;
+        int[][] dp = new int[rows][columns];
+        for (int i = 0; i < rows; i++) {
+            for (int j = 0; j < columns; j++) {
+                if (matrix[i][j] == '1') {
+                    if (i == 0 || j == 0) {
+                        dp[i][j] = 1;
+                    } else {
+                        dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
+                    }
+                    maxSide = Math.max(maxSide, dp[i][j]);
+                }
+            }
+        }
+        int maxSquare = maxSide * maxSide;
+        return maxSquare;
+    }
+
+    /**
+     * 选择排序：每次都选择最小的数据。
+     *
+     * @param a
+     */
+    public void chooseSort(int[] a) {
+        int n = a.length;
+        if (n <= 1) {
+            return;
+        }
+        // 只要n-1次比较就好。
+        for (int i = 0; i < n -1; i++) {
+            int minPos = i;
+            for (int j = i; j < n; j++) {
+                if (a[j] < a[minPos]) {
+                    minPos = j;
+                }
+            }
+            int temp = a[i];
+            a[i] = a[minPos];
+            a[minPos] = temp;
+        }
+    }
+
+    /**
+     * 主要是要一个分支算法。
+     *
+     * @param nums
+     * @return
+     */
+    public int reversePairsSolution(int[] nums) {
+        if (nums.length == 0) {
+            return 0;
+        }
+        // 执行归并排序
+        sort(nums);
+        return count;
+    }
+
+    private int[] temp;
+
+    public void sort(int[] nums) {
+        temp = new int[nums.length];
+        sort(nums, 0, nums.length - 1);
+    }
+
+    // 归并排序
+    private void sort(int[] nums, int lo, int hi) {
+        if (lo == hi) {
+            return;
+        }
+        int mid = lo + (hi - lo) / 2;
+        sort(nums, lo, mid);
+        sort(nums, mid + 1, hi);
+        merge(nums, lo, mid, hi);
+    }
+
+    // 记录「翻转对」的个数
+    private int count = 0;
+
+    private void merge(int[] nums, int lo, int mid, int hi) {
+        for (int i = lo; i <= hi; i++) {
+            temp[i] = nums[i];
+        }
+
+        // 进行效率优化，维护左闭右开区间 [mid+1, end) 中的元素乘 2 小于 nums[i]
+        // 为什么 end 是开区间？因为这样的话可以保证初始区间 [mid+1, mid+1) 是一个空区间
+        int end = mid + 1;
+        for (int i = lo; i <= mid; i++) {
+            // nums 中的元素可能较大，乘 2 可能溢出，所以转化成 long
+            while (end <= hi && nums[i] > nums[end]) {
+                end++;
+            }
+            count += end - (mid + 1);
+        }
+
+        // 数组双指针技巧，合并两个有序数组
+        int i = lo, j = mid + 1;
+        for (int p = lo; p <= hi; p++) {
+            if (i == mid + 1) {
+                nums[p] = temp[j++];
+            } else if (j == hi + 1) {
+                nums[p] = temp[i++];
+            } else if (temp[i] > temp[j]) {
+                nums[p] = temp[j++];
+            } else {
+                nums[p] = temp[i++];
+            }
+        }
+    }
+
+
+    public int reversePairsMe(int[] nums) {
+        if (nums.length == 0) {
+            return 0;
+        }
+        // 执行归并排序
+        sort1(nums);
+        return count;
+    }
+
+    int[] storage = null;
+    public void sort1(int[] nums) {
+        storage = nums;
+
+        int left = 0, right = nums.length, mid = left +  (right - left )/2;
+    }
+
+    public void mergeByMe(int[] nums, int l, int r, int mid) {
+        // 计数逆序对的个数
+        int end = mid + 1;
+        for (int i = l; i <= mid; i++) {
+            // nums 中的元素可能较大，乘 2 可能溢出，所以转化成 long
+            while (end <= r && nums[i] > nums[end]) {
+                end++;
+            }
+            count += end - (mid + 1);
+        }
+        // 数组双指针技巧，合并两个有序数组
+        int i = l, j = mid + 1;
+        for (int k = l; k <= r; k++) {
+            if (i == mid + 1) {
+                nums[k] = temp[j++];
+            } else if (j == r+1) {
+                nums[k] = temp[i++];
+            } else if(temp[i] > temp[j]) {
+                nums[k] = nums[j++];
+            } else  {
+                nums[k] =  nums[i++];
+            }
+        }
+    }
+
+}
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"ad8e8bd9-6123-4cf1-803e-ee38b6d489e6\" name=\"Changes\" comment=\"\" />\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">\r\n    <property name=\"RequestMappingsPanelOrder0\" value=\"0\" />\r\n    <property name=\"RequestMappingsPanelOrder1\" value=\"1\" />\r\n    <property name=\"RequestMappingsPanelWidth0\" value=\"75\" />\r\n    <property name=\"RequestMappingsPanelWidth1\" value=\"75\" />\r\n  </component>\r\n  <component name=\"RunManager\">\r\n    <configuration name=\"StockApplication\" type=\"SpringBootApplicationConfigurationType\" factoryName=\"Spring Boot\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"stock\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"com.example.stock.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <option name=\"SPRING_BOOT_MAIN_CLASS\" value=\"com.example.stock.StockApplication\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Spring Boot.StockApplication\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"TaskManager\">\r\n    <servers />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n    <option name=\"oldMeFiltersMigrated\" value=\"true\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision cf8ea38fa9da362ec8a79646980a64be2e30bae6)
+++ b/.idea/workspace.xml	(date 1699092525304)
@@ -4,54 +4,514 @@
     <option name="autoReloadType" value="SELECTIVE" />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="ad8e8bd9-6123-4cf1-803e-ee38b6d489e6" name="Changes" comment="" />
+    <list default="true" id="ad8e8bd9-6123-4cf1-803e-ee38b6d489e6" name="Changes" comment="">
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/design/Decorateor.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/design/Faceor.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/design/FlyWeight.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/design/NullObject.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/abTest/A1023.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/abTest/Employee.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/abTest/MyApplication.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/abTest/Test.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/abTest/TestImpl.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/algorithm/Huawei.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/algorithm/Leet150.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/algorithm/Maoao.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/algorithm/MergeSort.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/algorithm/MidAlg.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/algorithm/StackToList.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/algorithm/ZhaoShang.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/arr/ArrSolution.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/daily/LRUCache.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet0901.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet0902.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1024.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1028.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1029.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1030.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1104.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/daily/MyRun.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/daily/Test.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/daily/TestSync.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/daily/ThreadTestPriority.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/daily/Z.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/dp/LongSubList.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/dp/MinJump.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/graph/Graph.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/link/Leet1020.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/link/ListNode.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/link/SumLinkList.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/lock/DataProcessor.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/lock/PrintABC.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/math/MathAlg.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/math/MoneyTest.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/single/SingleEnum.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/single/Singleton.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/single/Singleton1.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/single/SingletonDCL.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/single/SingletonStatic.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/single/TestSingle.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/string/Longest.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/test.json" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/tree/FirstKth.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/tree/Flatten.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/problem/UpdateTask.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/web/src/main/java/org/example/web/meituan/TimeProblem.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/web/src/main/java/org/example/web/socket/TCPTest.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/web/src/main/java/org/example/web/socket/chapter03/UDPTest.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/web/src/main/java/org/example/web/socket/nettyTest/HalfPacketTest.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/web/src/main/java/org/example/web/socket/nettyTest/ServerHandler.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/web/src/main/java/org/example/web/socket/nettyTest/ToIntegerDecoder.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/web/src/main/java/org/example/web/socket/nettyTest/client/NettyClient.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/web/src/main/java/org/example/web/socket/nettyTest/config/NettyConfig.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/web/src/main/java/org/example/web/socket/nettyTest/hanlder/TCPCountHandler.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/common/web/src/main/java/org/example/web/socket/nettyTest/server/NettyServer.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/common/core/pom.xml" beforeDir="false" afterPath="$PROJECT_DIR$/common/core/pom.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/Leetcode1234.java" beforeDir="false" afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/Leetcode1234.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/dfs/Solution.java" beforeDir="false" afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/dfs/Solution.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/dp/Stock.java" beforeDir="false" afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/dp/Stock.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/tree/TreeNode.java" beforeDir="false" afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/tree/TreeNode.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/util/FileUtils.java" beforeDir="false" afterPath="$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/util/FileUtils.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/common/web/pom.xml" beforeDir="false" afterPath="$PROJECT_DIR$/common/web/pom.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/common/web/src/main/java/org/example/web/meituan/ThreadLocalProblem.java" beforeDir="false" afterPath="$PROJECT_DIR$/common/web/src/main/java/org/example/web/meituan/ThreadLocalProblem.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/pom.xml" beforeDir="false" afterPath="$PROJECT_DIR$/pom.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/stock/src/main/java/com/example/stock/basic/CompleteFutureTest.java" beforeDir="false" afterPath="$PROJECT_DIR$/stock/src/main/java/com/example/stock/basic/CompleteFutureTest.java" afterDir="false" />
+    </list>
+    <list id="ab55655a-3fd4-479a-9c8a-d4eba35d10a8" name="不提交" comment="test" />
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
     <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
     <option name="LAST_RESOLUTION" value="IGNORE" />
   </component>
+  <component name="FileTemplateManagerImpl">
+    <option name="RECENT_TEMPLATES">
+      <list>
+        <option value="FxmlFile" />
+        <option value="Class" />
+      </list>
+    </option>
+  </component>
   <component name="Git.Settings">
+    <option name="PREVIOUS_COMMIT_AUTHORS">
+      <list>
+        <option value="lejun &lt;lejun3389@qq.com&gt;" />
+      </list>
+    </option>
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
+    <option name="UPDATE_TYPE" value="REBASE" />
+  </component>
+  <component name="GitSEFilterConfiguration">
+    <file-type-list>
+      <filtered-out-file-type name="LOCAL_BRANCH" />
+      <filtered-out-file-type name="REMOTE_BRANCH" />
+      <filtered-out-file-type name="TAG" />
+      <filtered-out-file-type name="COMMIT_BY_MESSAGE" />
+    </file-type-list>
+  </component>
+  <component name="HighlightingSettingsPerFile">
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/util/concurrent/locks/LockSupport.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$MAVEN_REPOSITORY$/cn/hutool/hutool-all/5.7.22/hutool-all-5.7.22.jar!/cn/hutool/core/util/NumberUtil.class" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/util/zip/DeflaterOutputStream.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/util/concurrent/locks/AbstractQueuedSynchronizer.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/util/zip/ZipOutputStream.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/util/concurrent/locks/ReentrantLock.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$MAVEN_REPOSITORY$/cn/hutool/hutool-all/5.7.22/hutool-all-5.7.22.jar!/cn/hutool/core/compress/ZipWriter.class" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/lang/System.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/util/concurrent/ScheduledExecutorService.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/jre/lib/rt.jar!/sun/misc/Unsafe.class" root0="SKIP_INSPECTION" />
+    <setting file="jar://$MAVEN_REPOSITORY$/io/netty/netty-all/4.1.55.Final/netty-all-4.1.55.Final.jar!/io/netty/channel/nio/NioEventLoopGroup.class" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/util/Calendar.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/util/Map.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/util/concurrent/Executor.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/lang/Runnable.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/util/ArrayList.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/util/Arrays.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/lang/IllegalArgumentException.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/math/BigDecimal.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/math/RoundingMode.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/security/Principal.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/util/Formatter.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/nio/channels/spi/SelectorProvider.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/jre/lib/rt.jar!/sun/reflect/NativeMethodAccessorImpl.class" root0="SKIP_INSPECTION" />
+    <setting file="jar://$MAVEN_REPOSITORY$/org/projectlombok/lombok/1.18.26/lombok-1.18.26.jar!/lombok/val.class" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/util/List.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/lang/String.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$MAVEN_REPOSITORY$/junit/junit/4.13.2/junit-4.13.2.jar!/org/junit/runner/Description.class" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/util/Comparator.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/net/URL.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/util/PriorityQueue.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$MAVEN_REPOSITORY$/cn/hutool/hutool-all/5.7.22/hutool-all-5.7.22.jar!/cn/hutool/core/util/ZipUtil.class" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/util/concurrent/ExecutionException.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/lang/StringBuffer.java" root0="SKIP_INSPECTION" />
+    <setting file="jar://$PROJECT_DIR$/../../../../jdk/src.zip!/java/lang/Thread.java" root0="SKIP_INSPECTION" />
+  </component>
+  <component name="ProjectId" id="2WsWCPAPhk9nL4frb3cQS3C32tD" />
+  <component name="ProjectViewState">
+    <option name="autoscrollToSource" value="true" />
+    <option name="hideEmptyMiddlePackages" value="true" />
+    <option name="showExcludedFiles" value="false" />
+    <option name="showLibraryContents" value="true" />
+    <option name="showMembers" value="true" />
   </component>
   <component name="PropertiesComponent">
     <property name="RequestMappingsPanelOrder0" value="0" />
     <property name="RequestMappingsPanelOrder1" value="1" />
     <property name="RequestMappingsPanelWidth0" value="75" />
     <property name="RequestMappingsPanelWidth1" value="75" />
+    <property name="RunOnceActivity.OpenProjectViewOnStart" value="true" />
+    <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />
+    <property name="WebServerToolWindowFactoryState" value="false" />
+    <property name="last_opened_file_path" value="$PROJECT_DIR$/../../../../../entertainment/video/socket/code" />
+    <property name="nodejs_package_manager_path" value="npm" />
+    <property name="settings.editor.selected.configurable" value="preferences.lookFeel" />
+    <property name="vue.rearranger.settings.migration" value="true" />
   </component>
-  <component name="RunManager">
-    <configuration name="StockApplication" type="SpringBootApplicationConfigurationType" factoryName="Spring Boot" temporary="true" nameIsGenerated="true">
-      <module name="stock" />
+  <component name="RunManager" selected="Application.TimeProblem">
+    <configuration name="NullObject$TestNotNull" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
+      <option name="MAIN_CLASS_NAME" value="org.example.common.core.design.NullObject$TestNotNull" />
+      <module name="core" />
+      <extension name="coverage">
+        <pattern>
+          <option name="PATTERN" value="org.example.common.core.design.*" />
+          <option name="ENABLED" value="true" />
+        </pattern>
+      </extension>
+      <method v="2">
+        <option name="Make" enabled="true" />
+      </method>
+    </configuration>
+    <configuration name="TimeProblem" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
+      <option name="MAIN_CLASS_NAME" value="org.example.web.meituan.TimeProblem" />
+      <module name="web" />
+      <extension name="coverage">
+        <pattern>
+          <option name="PATTERN" value="org.example.web.meituan.*" />
+          <option name="ENABLED" value="true" />
+        </pattern>
+      </extension>
+      <method v="2">
+        <option name="Make" enabled="true" />
+      </method>
+    </configuration>
+    <configuration name="Leet1102.testInOrder" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
+      <module name="core" />
+      <extension name="coverage">
+        <pattern>
+          <option name="PATTERN" value="org.example.common.core.leetcode.daily.*" />
+          <option name="ENABLED" value="true" />
+        </pattern>
+      </extension>
+      <option name="PACKAGE_NAME" value="org.example.common.core.leetcode.daily" />
+      <option name="MAIN_CLASS_NAME" value="org.example.common.core.leetcode.daily.Leet1102" />
+      <option name="METHOD_NAME" value="testInOrder" />
+      <option name="TEST_OBJECT" value="method" />
+      <method v="2">
+        <option name="Make" enabled="true" />
+      </method>
+    </configuration>
+    <configuration name="Leet1102.testOrders" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
+      <module name="core" />
+      <extension name="coverage">
+        <pattern>
+          <option name="PATTERN" value="org.example.common.core.leetcode.daily.*" />
+          <option name="ENABLED" value="true" />
+        </pattern>
+      </extension>
+      <option name="PACKAGE_NAME" value="org.example.common.core.leetcode.daily" />
+      <option name="MAIN_CLASS_NAME" value="org.example.common.core.leetcode.daily.Leet1102" />
+      <option name="METHOD_NAME" value="testOrders" />
+      <option name="TEST_OBJECT" value="method" />
+      <method v="2">
+        <option name="Make" enabled="true" />
+      </method>
+    </configuration>
+    <configuration name="ZhaoShang.testDictionary" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
+      <module name="core" />
       <extension name="coverage">
         <pattern>
-          <option name="PATTERN" value="com.example.stock.*" />
+          <option name="PATTERN" value="org.example.common.core.leetcode.algorithm.*" />
           <option name="ENABLED" value="true" />
         </pattern>
       </extension>
-      <option name="SPRING_BOOT_MAIN_CLASS" value="com.example.stock.StockApplication" />
+      <option name="PACKAGE_NAME" value="org.example.common.core.leetcode.algorithm" />
+      <option name="MAIN_CLASS_NAME" value="org.example.common.core.leetcode.algorithm.ZhaoShang" />
+      <option name="METHOD_NAME" value="testDictionary" />
+      <option name="TEST_OBJECT" value="method" />
       <method v="2">
         <option name="Make" enabled="true" />
       </method>
     </configuration>
     <recent_temporary>
       <list>
-        <item itemvalue="Spring Boot.StockApplication" />
+        <item itemvalue="Application.TimeProblem" />
+        <item itemvalue="Application.NullObject$TestNotNull" />
+        <item itemvalue="JUnit.ZhaoShang.testDictionary" />
+        <item itemvalue="JUnit.Leet1102.testOrders" />
+        <item itemvalue="JUnit.Leet1102.testInOrder" />
       </list>
     </recent_temporary>
   </component>
+  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
   <component name="TaskManager">
+    <task id="LOCAL-00001" summary="树的变形，对同一个层级的下一个节点添加一个引用的指针">
+      <created>1697445855252</created>
+      <option name="number" value="00001" />
+      <option name="presentableId" value="LOCAL-00001" />
+      <option name="project" value="LOCAL" />
+      <updated>1697445855252</updated>
+    </task>
+    <task active="true" id="Default" summary="Default task">
+      <changelist id="ad8e8bd9-6123-4cf1-803e-ee38b6d489e6" name="Changes" comment="多线程之scheduleFixRate的讨论" />
+      <created>1697521650860</created>
+      <option name="number" value="Default" />
+      <option name="presentableId" value="Default" />
+      <updated>1697521650860</updated>
+      <workItem from="1697521652472" duration="2390000" />
+      <workItem from="1697527671168" duration="2039000" />
+      <workItem from="1697600597254" duration="6511000" />
+      <workItem from="1697698616554" duration="2021000" />
+      <workItem from="1697780596264" duration="5506000" />
+      <workItem from="1697790885716" duration="911000" />
+      <workItem from="1697870789973" duration="36000" />
+      <workItem from="1697962192522" duration="5559000" />
+      <workItem from="1698039690475" duration="7715000" />
+      <workItem from="1698113262769" duration="4449000" />
+      <workItem from="1698126982785" duration="1279000" />
+      <workItem from="1698134815132" duration="23000" />
+      <workItem from="1698136763696" duration="26000" />
+      <workItem from="1698288347168" duration="494000" />
+      <workItem from="1698288861148" duration="2520000" />
+      <workItem from="1698299180836" duration="237000" />
+      <workItem from="1698310835236" duration="312000" />
+      <workItem from="1698389849035" duration="728000" />
+      <workItem from="1698461442522" duration="1688000" />
+      <workItem from="1698476739312" duration="2962000" />
+      <workItem from="1698545178693" duration="1726000" />
+      <workItem from="1698561405732" duration="1000000" />
+      <workItem from="1698646554131" duration="618000" />
+      <workItem from="1698653923931" duration="497000" />
+      <workItem from="1698809981458" duration="1197000" />
+      <workItem from="1698891988400" duration="5323000" />
+      <workItem from="1698902827037" duration="6756000" />
+      <workItem from="1698915936755" duration="332000" />
+      <workItem from="1698979956301" duration="260000" />
+      <workItem from="1698990083110" duration="8627000" />
+      <workItem from="1699077955087" duration="1104000" />
+      <workItem from="1699085700522" duration="304000" />
+      <workItem from="1699086309769" duration="2222000" />
+      <workItem from="1699089193264" duration="2763000" />
+      <workItem from="1699092224217" duration="299000" />
+    </task>
+    <task id="LOCAL-00002" summary="最长的有效括号长度">
+      <created>1697981793927</created>
+      <option name="number" value="00002" />
+      <option name="presentableId" value="LOCAL-00002" />
+      <option name="project" value="LOCAL" />
+      <updated>1697981793927</updated>
+    </task>
+    <task id="LOCAL-00003" summary="股票的各类基本操作">
+      <created>1698049301865</created>
+      <option name="number" value="00003" />
+      <option name="presentableId" value="LOCAL-00003" />
+      <option name="project" value="LOCAL" />
+      <updated>1698049301865</updated>
+    </task>
+    <task id="LOCAL-00004" summary="增加树的遍历和构建树功能">
+      <created>1698117708157</created>
+      <option name="number" value="00004" />
+      <option name="presentableId" value="LOCAL-00004" />
+      <option name="project" value="LOCAL" />
+      <updated>1698117708157</updated>
+    </task>
+    <task id="LOCAL-00005" summary="罗马数字、字符转换的处理">
+      <created>1698291372331</created>
+      <option name="number" value="00005" />
+      <option name="presentableId" value="LOCAL-00005" />
+      <option name="project" value="LOCAL" />
+      <updated>1698291372331</updated>
+    </task>
+    <task id="LOCAL-00006" summary="二叉树前中后序的非递归形式的输出。">
+      <created>1698905640469</created>
+      <option name="number" value="00006" />
+      <option name="presentableId" value="LOCAL-00006" />
+      <option name="project" value="LOCAL" />
+      <updated>1698905640470</updated>
+    </task>
+    <task id="LOCAL-00007" summary="fix:二叉树前中后序的非递归形式的输出。">
+      <created>1698909394858</created>
+      <option name="number" value="00007" />
+      <option name="presentableId" value="LOCAL-00007" />
+      <option name="project" value="LOCAL" />
+      <updated>1698909394858</updated>
+    </task>
+    <task id="LOCAL-00008" summary="滑动窗口的使用">
+      <created>1698992914679</created>
+      <option name="number" value="00008" />
+      <option name="presentableId" value="LOCAL-00008" />
+      <option name="project" value="LOCAL" />
+      <updated>1698992914680</updated>
+    </task>
+    <task id="LOCAL-00009" summary="滑动窗口的使用">
+      <created>1698996058385</created>
+      <option name="number" value="00009" />
+      <option name="presentableId" value="LOCAL-00009" />
+      <option name="project" value="LOCAL" />
+      <updated>1698996058385</updated>
+    </task>
+    <task id="LOCAL-00010" summary="线程重用导致的用户信息紊乱的问题">
+      <created>1698996753592</created>
+      <option name="number" value="00010" />
+      <option name="presentableId" value="LOCAL-00010" />
+      <option name="project" value="LOCAL" />
+      <updated>1698996753592</updated>
+    </task>
+    <option name="localTasksCounter" value="11" />
     <servers />
   </component>
+  <component name="TypeScriptGeneratedFilesManager">
+    <option name="version" value="3" />
+  </component>
   <component name="Vcs.Log.Tabs.Properties">
     <option name="TAB_STATES">
       <map>
         <entry key="MAIN">
           <value>
-            <State />
+            <State>
+              <option name="FILTERS">
+                <map>
+                  <entry key="branch">
+                    <value>
+                      <list>
+                        <option value="socket" />
+                      </list>
+                    </value>
+                  </entry>
+                </map>
+              </option>
+            </State>
+          </value>
+        </entry>
+      </map>
+    </option>
+    <option name="RECENT_FILTERS">
+      <map>
+        <entry key="Branch">
+          <value>
+            <list>
+              <RecentGroup>
+                <option name="FILTER_VALUES">
+                  <option value="socket" />
+                </option>
+              </RecentGroup>
+              <RecentGroup>
+                <option name="FILTER_VALUES">
+                  <option value="origin/main" />
+                </option>
+              </RecentGroup>
+            </list>
           </value>
         </entry>
       </map>
     </option>
     <option name="oldMeFiltersMigrated" value="true" />
   </component>
+  <component name="VcsManagerConfiguration">
+    <MESSAGE value="树的变形，对同一个层级的下一个节点添加一个引用的指针" />
+    <MESSAGE value="最长的有效括号长度" />
+    <MESSAGE value="股票的各类基本操作" />
+    <MESSAGE value="增加树的遍历和构建树功能" />
+    <MESSAGE value="罗马数字、字符转换的处理" />
+    <MESSAGE value="二叉树前中后序的非递归形式的输出。" />
+    <MESSAGE value="fix:二叉树前中后序的非递归形式的输出。" />
+    <MESSAGE value="滑动窗口的使用" />
+    <MESSAGE value="线程重用导致的用户信息紊乱的问题" />
+    <option name="LAST_COMMIT_MESSAGE" value="线程重用导致的用户信息紊乱的问题" />
+  </component>
+  <component name="XDebuggerManager">
+    <breakpoint-manager>
+      <breakpoints>
+        <line-breakpoint enabled="true" type="java-line">
+          <url>file://$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/algorithm/Leet150.java</url>
+          <line>112</line>
+          <option name="timeStamp" value="1" />
+        </line-breakpoint>
+        <line-breakpoint enabled="true" type="java-line">
+          <url>file://$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet0902.java</url>
+          <line>54</line>
+          <option name="timeStamp" value="2" />
+        </line-breakpoint>
+        <line-breakpoint enabled="true" type="java-line">
+          <url>file://$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/daily/Z.java</url>
+          <line>28</line>
+          <option name="timeStamp" value="6" />
+        </line-breakpoint>
+        <line-breakpoint enabled="true" type="java-line">
+          <url>file://$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/daily/Z.java</url>
+          <line>25</line>
+          <option name="timeStamp" value="7" />
+        </line-breakpoint>
+        <line-breakpoint enabled="true" type="java-line">
+          <url>file://$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/abTest/TestImpl.java</url>
+          <line>22</line>
+          <option name="timeStamp" value="8" />
+        </line-breakpoint>
+        <line-breakpoint enabled="true" type="java-line">
+          <url>file://$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/link/SumLinkList.java</url>
+          <line>483</line>
+          <option name="timeStamp" value="10" />
+        </line-breakpoint>
+        <line-breakpoint enabled="true" type="java-line">
+          <url>file://$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/link/SumLinkList.java</url>
+          <line>560</line>
+          <option name="timeStamp" value="12" />
+        </line-breakpoint>
+        <line-breakpoint enabled="true" type="java-line">
+          <url>file://$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/link/SumLinkList.java</url>
+          <line>551</line>
+          <option name="timeStamp" value="13" />
+        </line-breakpoint>
+        <line-breakpoint enabled="true" type="java-line">
+          <url>file://$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/tree/Flatten.java</url>
+          <line>534</line>
+          <option name="timeStamp" value="16" />
+        </line-breakpoint>
+        <line-breakpoint enabled="true" type="java-line">
+          <url>file://$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/link/SumLinkList.java</url>
+          <line>164</line>
+          <option name="timeStamp" value="18" />
+        </line-breakpoint>
+        <line-breakpoint enabled="true" type="java-line">
+          <url>file://$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/link/SumLinkList.java</url>
+          <line>183</line>
+          <option name="timeStamp" value="19" />
+        </line-breakpoint>
+        <line-breakpoint enabled="true" type="java-line">
+          <url>file://$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/Leetcode1234.java</url>
+          <line>44</line>
+          <option name="timeStamp" value="20" />
+        </line-breakpoint>
+        <line-breakpoint enabled="true" type="java-method">
+          <url>file://$PROJECT_DIR$/common/core/src/main/java/org/example/common/core/leetcode/abTest/TestImpl.java</url>
+          <line>21</line>
+          <properties class="org.example.common.core.leetcode.abTest.TestImpl" method="methodA">
+            <option name="EMULATED" value="true" />
+          </properties>
+          <option name="timeStamp" value="9" />
+        </line-breakpoint>
+      </breakpoints>
+    </breakpoint-manager>
+  </component>
+  <component name="XSLT-Support.FileAssociations.UIState">
+    <expand />
+    <select />
+  </component>
+  <component name="com.intellij.coverage.CoverageDataManagerImpl">
+    <SUITE FILE_PATH="coverage/cloud$BuildSolution_test.ic" NAME="BuildSolution.test Coverage Results" MODIFIED="1693795425573" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="idea" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false">
+      <FILTER>org.example.common.core.leetcode.tree.*</FILTER>
+    </SUITE>
+    <SUITE FILE_PATH="coverage/cloud$Longest_testGroup.ic" NAME="Longest.testGroup Coverage Results" MODIFIED="1695891675704" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="idea" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false">
+      <FILTER>org.example.common.core.leetcode.string.*</FILTER>
+    </SUITE>
+  </component>
 </project>
\ No newline at end of file
Index: common/core/src/main/java/org/example/common/core/leetcode/single/SingletonDCL.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/single/SingletonDCL.java b/common/core/src/main/java/org/example/common/core/leetcode/single/SingletonDCL.java
new file mode 100644
--- /dev/null	(date 1698633783442)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/single/SingletonDCL.java	(date 1698633783442)
@@ -0,0 +1,25 @@
+package org.example.common.core.leetcode.single;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:单例的实现类:懒汉式
+ * @time: 2023/8/24 14:58
+ */
+public class SingletonDCL {
+    private volatile static SingletonDCL instance;
+    private SingletonDCL(){
+        System.out.println(Thread.currentThread().getName()+"创建了对象");
+    }
+
+    public static SingletonDCL getInstance(){
+        if (instance == null) {
+            synchronized (SingletonDCL.class) {
+                if (null == instance) {
+                     instance = new SingletonDCL();
+                }
+            }
+        }
+        return instance;
+    }
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/single/Singleton1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/single/Singleton1.java b/common/core/src/main/java/org/example/common/core/leetcode/single/Singleton1.java
new file mode 100644
--- /dev/null	(date 1698633783438)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/single/Singleton1.java	(date 1698633783438)
@@ -0,0 +1,17 @@
+package org.example.common.core.leetcode.single;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:单例的实现类:懒汉式
+ * @time: 2023/8/24 14:58
+ */
+public class Singleton1 {
+    private static Singleton1 instance = null;
+    public static Singleton1 getInstance(){
+        if (instance == null) {
+            instance = new Singleton1();
+        }
+        return instance;
+    }
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/single/TestSingle.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/single/TestSingle.java b/common/core/src/main/java/org/example/common/core/leetcode/single/TestSingle.java
new file mode 100644
--- /dev/null	(date 1698633783445)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/single/TestSingle.java	(date 1698633783445)
@@ -0,0 +1,24 @@
+package org.example.common.core.leetcode.single;
+
+import lombok.extern.slf4j.Slf4j;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/8/24 15:05
+ */
+@Slf4j
+public class TestSingle {
+    public static void main(String[] args) {
+
+        for (int i = 0; i < 10; i++) {
+            new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    SingletonDCL.getInstance();
+                }
+            }).start();
+        }
+    }
+}
Index: common/core/src/main/java/org/example/common/core/util/FileUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.example.common.core.util;\r\n\r\nimport cn.hutool.core.util.ObjectUtil;\r\nimport cn.hutool.core.util.ZipUtil;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.nio.file.*;\r\nimport java.nio.file.attribute.BasicFileAttributes;\r\nimport java.util.*;\r\nimport java.util.stream.Collectors;\r\n\r\n/**\r\n * @Author:lejun\r\n * @project:cloud\r\n * @descript:对文件的基本操作：{下载zip，合成zip等操作}\r\n * @time: 2023/1/1 15:17\r\n */\r\n@Slf4j\r\npublic class FileUtils {\r\n\r\n    /**\r\n     * 文件的压缩包生成\r\n     *\r\n     * @param filesNames\r\n     * @param filePath\r\n     * @param targetPath\r\n     * @param name 新生成的zip文件名字\r\n     * @param delete 是否删除原有的文件\r\n     */\r\n    public void buildZip(List<String> filesNames, Path filePath, Path targetPath,\r\n                           String name, boolean delete) {\r\n        try {\r\n            List<File> fileList = new ArrayList<>();\r\n            for (String fileName : filesNames) {\r\n                Path resolve = filePath.resolve(fileName);\r\n                File file = new File(resolve.toString());\r\n                if (ObjectUtil.isNotEmpty(file)) {\r\n                    fileList.add(file);\r\n                }\r\n            }\r\n            File[] files = fileList.stream().toArray(File[]::new);\r\n            Path composeName = targetPath.resolve(name);\r\n            File zipFile = new File(composeName.toString());\r\n            ZipUtil.zip(zipFile, true, files);\r\n            log.info(\"文件{}已经压缩了！\", name);\r\n            if (delete) {\r\n                for (File file : fileList) {\r\n                    file.delete();\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            log.error(\"压缩文件出错！\", e) ;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 对压缩文件进行解压处理\r\n     *\r\n     * @param path\r\n     * @param name\r\n     */\r\n    public void upZip(String path, String name) {\r\n\r\n    }\r\n\r\n    public static void main(String[] args) throws IOException {\r\n        // C:\\Users\\lejun\\Desktop\\world\\test\r\n        String pathDir = \"C:\\\\Users\\\\lejun\\\\Desktop\\\\world\\\\test\";\r\n\r\n        FileUtils fileUtils = new FileUtils();\r\n        List<String> strings = readFileName(pathDir);\r\n        log.info(\"================{}\", strings);\r\n\r\n//        List<String> strings = Arrays.asList(\"dir.zip\", \"语音.zip\", \"短信.zip\");\r\n//        Path path = Paths.get(pathDir);\r\n//        fileUtils.buildZip(strings, path, path, \"合成文件.zip\", true);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * 只是粗略的读取所有的file的绝对路径！\r\n     * @param path\r\n     * @return\r\n     * @throws IOException\r\n     */\r\n    public static List<String> readFileName(String path) throws IOException {\r\n        Path startingDir = Paths.get(path);\r\n        List<Path> result = new LinkedList();\r\n        Files.walkFileTree(startingDir, new FindJavaVisitor(result));\r\n        ArrayList<String> paths = new ArrayList<>();\r\n        result.stream().forEach(Path-> {\r\n            paths.add(Path.toString());\r\n        });\r\n        return paths;\r\n    }\r\n\r\n    /**\r\n     * 只需要唯一的内容，不重复的内容！\r\n     * @param path\r\n     * @throws IOException\r\n     */\r\n    public static List<String> readOneFileName(String path) throws IOException {\r\n        Path startingDir = Paths.get(path);\r\n        List<Path> result = new LinkedList();\r\n        Files.walkFileTree(startingDir, new FindJavaVisitor(result));\r\n        // 去重。***.mp3和***(live).mp3\r\n        Set<String> lives = new HashSet<>();\r\n        Set<String> music = new HashSet<>();\r\n        Set<String> distinctMusicName = new HashSet<>();\r\n        distinctMusicName.addAll(music);\r\n        List<Path> collectLive = result.stream().filter(s ->\r\n                s.toString().contains(\"(live)\")).collect(Collectors.toList());\r\n        List<Path> collectMusic = result.stream()\r\n                .filter(s->!collectLive.contains(s.toString()))\r\n                .collect(Collectors.toList());\r\n        for (String live : lives) {\r\n            String realName = live.substring(live.lastIndexOf(\"(\"), live.lastIndexOf(\")\") + 1);\r\n            if (!distinctMusicName.contains(realName)) {\r\n                distinctMusicName.add(live);\r\n            }\r\n        }\r\n        ArrayList<String> paths = new ArrayList<>();\r\n        distinctMusicName.stream().forEach(Path-> {\r\n            paths.add(Path);\r\n        });\r\n        return paths;\r\n    }\r\n\r\n    private static class FindJavaVisitor extends SimpleFileVisitor<Path> {\r\n        private List result;\r\n\r\n        public FindJavaVisitor(List result){\r\n            this.result = result;\r\n        }\r\n\r\n        @Override\r\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\r\n            //这里是需要对文件的名字记录\r\n            result.add(file);\r\n            return FileVisitResult.CONTINUE;\r\n        }\r\n\r\n        @Override\r\n        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\r\n            //访问到目录的时候 就会触发该方法 就可以对遍历的目录进行操作\r\n            System.out.println(\"正在操作的目录是：\"+dir);\r\n\r\n            return FileVisitResult.CONTINUE;\r\n        }\r\n\r\n        @Override\r\n//       做完后呢\r\n        public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\r\n            return super.postVisitDirectory(dir, exc);\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/util/FileUtils.java b/common/core/src/main/java/org/example/common/core/util/FileUtils.java
--- a/common/core/src/main/java/org/example/common/core/util/FileUtils.java	(revision cf8ea38fa9da362ec8a79646980a64be2e30bae6)
+++ b/common/core/src/main/java/org/example/common/core/util/FileUtils.java	(date 1698633783459)
@@ -2,9 +2,9 @@
 
 import cn.hutool.core.util.ObjectUtil;
 import cn.hutool.core.util.ZipUtil;
+import cn.hutool.http.server.HttpServerRequest;
+import cn.hutool.http.server.HttpServerResponse;
 import lombok.extern.slf4j.Slf4j;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import java.io.File;
 import java.io.IOException;
@@ -159,4 +159,16 @@
             return super.postVisitDirectory(dir, exc);
         }
     }
+
+    /**
+     * 实现断点续传下载的问题。
+     *
+     * @param request
+     * @param response
+     */
+    public void downLoad(HttpServerRequest request, HttpServerResponse response) {
+        
+    }
+
+
 }
Index: common/core/src/main/java/org/example/common/core/leetcode/single/SingletonStatic.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/single/SingletonStatic.java b/common/core/src/main/java/org/example/common/core/leetcode/single/SingletonStatic.java
new file mode 100644
--- /dev/null	(date 1698633783443)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/single/SingletonStatic.java	(date 1698633783443)
@@ -0,0 +1,26 @@
+package org.example.common.core.leetcode.single;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/8/24 15:22
+ */
+public class SingletonStatic {
+    /*
+    * 私有构造方法
+    * */
+    private SingletonStatic() {
+
+    }
+
+    public static SingletonStatic getInstance() {
+        return InnerClass.single;
+    }
+
+    // 静态的内部类
+    public static class InnerClass{
+        private static final SingletonStatic
+        single = new SingletonStatic();
+    }
+}
Index: common/web/pom.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <parent>\r\n        <artifactId>common</artifactId>\r\n        <groupId>org.example</groupId>\r\n        <version>1.0-SNAPSHOT</version>\r\n    </parent>\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <artifactId>web</artifactId>\r\n\r\n    <properties>\r\n        <maven.compiler.source>8</maven.compiler.source>\r\n        <maven.compiler.target>8</maven.compiler.target>\r\n    </properties>\r\n\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-aop</artifactId>\r\n            <optional>true</optional>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-validation</artifactId>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-web</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.example</groupId>\r\n            <artifactId>core</artifactId>\r\n            <version>1.0-SNAPSHOT</version>\r\n            <scope>compile</scope>\r\n        </dependency>\r\n    </dependencies>\r\n\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/web/pom.xml b/common/web/pom.xml
--- a/common/web/pom.xml	(revision cf8ea38fa9da362ec8a79646980a64be2e30bae6)
+++ b/common/web/pom.xml	(date 1698564329753)
@@ -26,6 +26,10 @@
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-validation</artifactId>
         </dependency>
+        <dependency>
+            <groupId>io.netty</groupId>
+            <artifactId>netty-all</artifactId>
+        </dependency>
 
         <dependency>
             <groupId>org.springframework.boot</groupId>
Index: common/core/src/main/java/org/example/common/core/leetcode/lock/PrintABC.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/lock/PrintABC.java b/common/core/src/main/java/org/example/common/core/leetcode/lock/PrintABC.java
new file mode 100644
--- /dev/null	(date 1698633783424)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/lock/PrintABC.java	(date 1698633783424)
@@ -0,0 +1,120 @@
+package org.example.common.core.leetcode.lock;
+
+import lombok.extern.slf4j.Slf4j;
+
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.ReentrantLock;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/9/4 14:49
+ */
+@Slf4j
+public class PrintABC {
+    ReentrantLock lock = new ReentrantLock();
+    Condition conditionA = lock.newCondition();
+    Condition conditionB = lock.newCondition();
+    Condition conditionC = lock.newCondition();
+    volatile int value = 0;
+
+    private int count;
+
+    public PrintABC(int count) {
+        this.count = count;
+    }
+
+    public static void main(String[] args) {
+        PrintABC printABC = new PrintABC(10);
+        printABC.printABC();
+    }
+
+    public void printABC() {
+        // 多个线程打印abc；
+        new Thread(new ThreadA()).start();
+        new Thread(new ThreadB()).start();
+        new Thread(new ThreadC()).start();
+    }
+
+    /**
+     * //                conditionB.await();
+     * //                conditionA.notify();
+     * 这时是我的理解。这时错误的。要的是如下的
+     * conditionA.await();
+     *
+     */
+    class ThreadA implements Runnable {
+
+        @Override
+        public void run() {
+            lock.lock();
+            try {
+                for (int i = 0; i < count; i++) {
+                    while (value % 3 != 0) {
+                        conditionA.await();
+                    }
+                    log.info("{}", Thread.currentThread().getName());
+                    System.out.println("A");
+                    conditionB.signal();
+                    value++;
+                }
+            } catch (Exception e) {
+
+            } finally {
+                lock.unlock();
+            }
+        }
+    }
+
+    class ThreadB implements Runnable {
+
+        @Override
+        public void run() {
+            lock.lock();
+            try {
+                for (int i = 0; i < count; i++) {
+                    while (value % 3 != 1) {
+                        conditionB.await();
+                    }
+                    log.info("{}", Thread.currentThread().getName());
+                    System.out.println("B");
+                    conditionC.signal();
+                    value++;
+                }
+            } catch (Exception e) {
+
+            } finally {
+                lock.unlock();
+            }
+        }
+    }
+
+    class ThreadC implements Runnable {
+
+        @Override
+        public void run() {
+            lock.lock();
+            try {
+                for (int i = 0; i < count; i++) {
+                    while (value % 3 != 2) {
+                        conditionC.await();
+                    }
+                    log.info("{}", Thread.currentThread().getName());
+                    System.out.println("C");
+                    conditionA.signal();
+                    value++;
+                }
+            } catch (Exception e) {
+
+            } finally {
+                lock.unlock();
+            }
+        }
+    }
+}
+
+
+class TestMultiThread {
+
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/lock/DataProcessor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/lock/DataProcessor.java b/common/core/src/main/java/org/example/common/core/leetcode/lock/DataProcessor.java
new file mode 100644
--- /dev/null	(date 1698633783422)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/lock/DataProcessor.java	(date 1698633783422)
@@ -0,0 +1,84 @@
+package org.example.common.core.leetcode.lock;
+
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/9/19 15:18
+ */
+public class DataProcessor {
+    private static final int CORE_POOL_SIZE = 10;
+    // 核心线程数
+    private static final int MAX_POOL_SIZE = 20;
+    // 最大线程数
+    private static final long KEEP_ALIVE_TIME = 60L;
+    // 空闲线程的存活时间（// 秒）
+    private static final int QUEUE_CAPACITY = 100;
+    // 任务队列容量
+    private static final String THREAD_NAME_PREFIX = "MyThreadPool-";
+    // 线程名称前缀
+
+    public static void main(String[] args) {
+        // 创建自定义线程池
+        ThreadPoolExecutor executor = new ThreadPoolExecutor(
+                CORE_POOL_SIZE,
+                MAX_POOL_SIZE,
+                KEEP_ALIVE_TIME,
+                TimeUnit.SECONDS,
+                new LinkedBlockingQueue<>(QUEUE_CAPACITY),
+                new MyThreadFactory(THREAD_NAME_PREFIX),
+                new MyRejectedExecutionHandler()
+        );
+
+        // 提交任务给线程池
+        for (int i = 1; i <= 20; i++) {
+            final int taskNumber = i;
+            executor.execute(() -> {
+                System.out.println("Task " + taskNumber + " is being processed by " + Thread.currentThread().getName());
+                // 在这里执行任务逻辑
+            });
+        }
+
+        // 关闭线程池
+        executor.shutdown();
+        try {
+            executor.awaitTermination(1, TimeUnit.MINUTES);
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+    }
+
+    // 自定义线程工厂
+    static class MyThreadFactory implements ThreadFactory {
+        private final String namePrefix;
+        private final AtomicInteger threadNumber = new AtomicInteger(1);
+
+        MyThreadFactory(String namePrefix) {
+            this.namePrefix = namePrefix;
+        }
+
+        @Override
+        public Thread newThread(Runnable r) {
+            Thread t = new Thread(r, namePrefix + threadNumber.getAndIncrement());
+            if (t.isDaemon()) {
+                t.setDaemon(false);
+            }
+            if (t.getPriority() != Thread.NORM_PRIORITY) {
+                t.setPriority(Thread.NORM_PRIORITY);
+            }
+            return t;
+        }
+    }
+
+    // 自定义拒绝策略
+    static class MyRejectedExecutionHandler implements RejectedExecutionHandler {
+        @Override
+        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
+            // 在这里处理任务被拒绝的情况
+            System.out.println("Task Rejected: " + r.toString());
+        }
+    }
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/tree/TreeNode.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.example.common.core.leetcode.tree;\r\n\r\n/**\r\n * @Author: lejun\r\n * @project: cloud\r\n * @description:\r\n * @time: 2023/8/22 16:06\r\n */\r\npublic class TreeNode {\r\n    int val;\r\n    TreeNode left;\r\n    TreeNode right;\r\n\r\n    TreeNode() {\r\n    }\r\n\r\n    TreeNode(int val) {\r\n        this.val = val;\r\n    }\r\n\r\n    TreeNode(int val, TreeNode left, TreeNode right) {\r\n        this.val = val;\r\n        this.left = left;\r\n        this.right = right;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"TreeNode{\" +\r\n                \"val=\" + val +\r\n                \", left=\" + left +\r\n                \", right=\" + right +\r\n                '}';\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/tree/TreeNode.java b/common/core/src/main/java/org/example/common/core/leetcode/tree/TreeNode.java
--- a/common/core/src/main/java/org/example/common/core/leetcode/tree/TreeNode.java	(revision cf8ea38fa9da362ec8a79646980a64be2e30bae6)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/tree/TreeNode.java	(date 1698906691766)
@@ -7,18 +7,18 @@
  * @time: 2023/8/22 16:06
  */
 public class TreeNode {
-    int val;
-    TreeNode left;
-    TreeNode right;
+    public int val;
+    public TreeNode left;
+    public TreeNode right;
 
     TreeNode() {
     }
 
-    TreeNode(int val) {
+    public TreeNode(int val) {
         this.val = val;
     }
 
-    TreeNode(int val, TreeNode left, TreeNode right) {
+    public TreeNode(int val, TreeNode left, TreeNode right) {
         this.val = val;
         this.left = left;
         this.right = right;
Index: common/core/src/main/java/org/example/common/core/problem/UpdateTask.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/problem/UpdateTask.java b/common/core/src/main/java/org/example/common/core/problem/UpdateTask.java
new file mode 100644
--- /dev/null	(date 1698633783456)
+++ b/common/core/src/main/java/org/example/common/core/problem/UpdateTask.java	(date 1698633783456)
@@ -0,0 +1,62 @@
+package org.example.common.core.problem;
+
+import cn.hutool.core.util.ObjectUtil;
+import lombok.extern.slf4j.Slf4j;
+
+import java.util.*;
+import java.util.stream.Collectors;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description: 用来维护starkLink的任务表，有唯一键的越约束
+ * @time: 2023/6/18 20:23
+ */
+@Slf4j
+public class UpdateTask {
+    static Map<String, String> taskMap = new HashMap<>();
+    static LinkedList task = new LinkedList<>();
+    public void update(String bckType, List<String> tasks) {
+
+        // 1. 查出数据库中是否存在
+        if (ObjectUtil.isEmpty(tasks)) {
+            // 插入新的任务
+            System.out.println("a new task will be insert into db!");
+            taskMap.put("bk", "a new bk task is on");
+            task.add("bk");
+        } else {
+            /**
+             * 1, bk --> bk
+             * 2, (bk, ck) --> ck 是什么呢？
+             * 3, bk --> ck 有需要更新bk任务 -->  更新时间，处理的状态。
+             */
+            List<String> notSameTask = tasks.stream().filter(m -> !m.equals(bckType)).collect(Collectors.toList());
+//            String sameTask = tasks.stream().filter(m -> m.equals(bckType)).collect(Collectors.toList()).get(0);
+//            // 相同的
+//            if (ObjectUtil.isEmpty(sameTask)) {
+//                // new task into db
+//
+//            }
+
+            if (ObjectUtil.isNotEmpty(notSameTask) && tasks.size() == 1) {
+                // insert
+                taskMap.put("ck", "a new ck Task!");
+                taskMap.put("bk", "a end bk task");
+                task.add("ck");
+            }
+        }
+    }
+
+    public static void main(String[] args) {
+
+        UpdateTask updateTask = new UpdateTask();
+        updateTask.update("bk", null);
+        log.info("{}\n{}", taskMap, task);
+        updateTask.update("ck", Arrays.asList("bk"));
+        log.info("{}\n{}", taskMap, task);
+//        updateTask.update("ck", Arrays.asList("bk", "ck"));
+//        log.info("{}\n{}", taskMap, task);
+
+    }
+
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/graph/Graph.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/graph/Graph.java b/common/core/src/main/java/org/example/common/core/leetcode/graph/Graph.java
new file mode 100644
--- /dev/null	(date 1698633783409)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/graph/Graph.java	(date 1698633783409)
@@ -0,0 +1,119 @@
+package org.example.common.core.leetcode.graph;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/8/31 15:39
+ */
+public class Graph {
+    /**
+     * 小岛的数量
+     * <p>
+     * 什么情况是说明是可以一个陆地的？
+     * 其实就是说1的连片的数据是多少的。
+     * </p>
+     *
+     * @param grid
+     * @return
+     */
+    public int numIslands(char[][] grid) {
+        int m = grid.length;
+        int n = grid[0].length;
+        int res = 0;
+        for (int i = 0; i < m; i++) {
+            for (int j = 0; j < n; j++) {
+                if (grid[i][j] == 1) {
+                    res++;
+                    dfs(grid, i, j);
+                }
+            }
+        }
+        return res;
+    }
+
+    public void dfs(char[][] grid, int r, int c) {
+        if (r >= grid.length || c >= grid[0].length) {
+            return;
+        }
+        if (grid[r][c] == '0') {
+            return;
+        }
+        dfs(grid, r + 1, c);
+        dfs(grid, r - 1, c);
+        dfs(grid, r, c + 1);
+        dfs(grid, r, c - 1);
+        grid[r][c] = 0;
+    }
+
+    public int islandPerimeter(int[][] grid) {
+        for (int r = 0; r < grid.length; r++) {
+            for (int c = 0; c < grid[0].length; c++) {
+                if (grid[r][c] == 1) {
+                    // 题目限制只有一个岛屿，计算一个即可
+                    return dfs(grid, r, c);
+                }
+            }
+        }
+        return 0;
+    }
+
+    int dfs(int[][] grid, int r, int c) {
+        // 函数因为「坐标 (r, c) 超出网格范围」返回，对应一条黄色的边
+        if (!inArea(grid, r, c)) {
+            return 1;
+        }
+        // 函数因为「当前格子是海洋格子」返回，对应一条蓝色的边
+        if (grid[r][c] == 0) {
+            return 1;
+        }
+        // 函数因为「当前格子是已遍历的陆地格子」返回，和周长没关系
+        if (grid[r][c] != 1) {
+            return 0;
+        }
+        grid[r][c] = 2;
+        return dfs(grid, r - 1, c)
+                + dfs(grid, r + 1, c)
+                + dfs(grid, r, c - 1)
+                + dfs(grid, r, c + 1);
+    }
+
+    // 判断坐标 (r, c) 是否在网格中
+    boolean inArea(int[][] grid, int r, int c) {
+        return 0 <= r && r < grid.length
+                && 0 <= c && c < grid[0].length;
+    }
+
+    // 记录下个数。
+    public int maxAreaOfIsland(int[][] grid) {
+        int m = grid.length;
+        int n = grid[0].length;
+        int res = 0;
+        for (int i = 0; i < m; i++) {
+            for (int j = 0; j < n; j++) {
+                if (grid[i][j] == 1) {
+                    int area = dfsArea(grid, i, j);
+                    res = Math.max(area, res);
+                }
+            }
+        }
+        return res;
+    }
+
+    int dfsArea(int[][] grid, int c, int r) {
+        if (!inArea(grid, r, c)) {
+            return 0;
+        }
+        if (grid[c][r] == '0') {
+            return 0;
+        }
+        grid[c][r] = '0';
+        return
+                dfsArea(grid, c + 1, r) +
+                        dfsArea(grid, c - 1, r) +
+                        dfsArea(grid, c, r + 1) +
+                        dfsArea(grid, c, r - 1) + 1;
+    }
+
+
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/link/SumLinkList.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/link/SumLinkList.java b/common/core/src/main/java/org/example/common/core/leetcode/link/SumLinkList.java
new file mode 100644
--- /dev/null	(date 1698633783416)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/link/SumLinkList.java	(date 1698633783416)
@@ -0,0 +1,839 @@
+package org.example.common.core.leetcode.link;
+
+import cn.hutool.core.util.ObjectUtil;
+import lombok.extern.slf4j.Slf4j;
+import lombok.val;
+import org.junit.Test;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description: 实现链表的值相加
+ * @time: 2023/6/5 21:41
+ */
+@Slf4j
+public class SumLinkList {
+    /**
+     * 实现值的相加， 生成对应的链表
+     * <p>
+     * 9 -- 3 -- 7
+     * <br></br>
+     * 6 -- 3
+     * <br>test 换行</br>
+     * <br>1 -- 0 -- 0 -- 0</br>
+     *
+     *
+     * </p>
+     * <p>
+     * 思路：首先要做的是REVERSE_ORDER，然后进行一个处理，有进位和移动？
+     *
+     * </p>
+     *
+     * @param node1
+     * @param node2
+     * @return
+     */
+    public ListNode getSum(ListNode node1, ListNode node2) {
+        if (ObjectUtil.isEmpty(node1) && ObjectUtil.isEmpty(node2)) {
+            return null;
+        }
+        if (ObjectUtil.isEmpty(node1)) {
+            return node2;
+        }
+        if (ObjectUtil.isEmpty(node2)) {
+            return node1;
+        }
+        // 实现值的相加；
+        ListNode reverseNode1 = reverse(node1);
+        ListNode reverseNode2 = reverse(node2);
+        int step = 1;
+        int plus = 0;
+        // 有一个到底了，就退出。
+        while (reverseNode1.next == null || reverseNode2.next == null) {
+            Integer sum = reverseNode1.val + reverseNode2.val;
+            if (sum > 10) {
+                plus = 1;
+            }
+            if (plus == 1) {
+                // 下次相加进位！
+            }
+        }
+
+//        LinkList linkList = new LinkList(-1);
+//        reverse(linkList, 1);
+        return null;
+    }
+
+    /**
+     * 从第几位开始反转链表
+     *
+     * @param linkList
+     * @param i
+     * @return
+     */
+    private ListNode reverse(ListNode linkList, Integer i) {
+        if (ObjectUtil.isEmpty(i)) {
+            // 反转全部的链表
+        }
+        return null;
+    }
+
+    /**
+     * 标准的反转链表
+     * <p>
+     * 有 a->(b -> c -> d)
+     * <br></br>
+     * a --> (d --> c --> b)
+     * </p>
+     *
+     * @param node
+     */
+    private ListNode reverse(ListNode node) {
+        if (ObjectUtil.isEmpty(node.next)) {
+            return node;
+        }
+        ListNode reverse = reverse(node.next);
+        node.next.next = node;
+        node.next = null;
+        return reverse;
+    }
+
+    @Test
+    public void test() {
+        ListNode head = new ListNode(1);
+        head.next = new ListNode(2);
+        head.next.next = new ListNode(3);
+        ListNode reverse = reverse(head);
+        System.out.println(reverse);
+    }
+
+    /**
+     * 反转整个链表
+     * <p>
+     * a -> b -> c
+     *
+     * @param head
+     */
+    public ListNode reverseByOther(ListNode head) {
+        ListNode pre, cur, next;
+        pre = null;
+        cur = head;
+        while (cur != null) {
+            next = cur.next;
+            // 一定要先连线的。后面在处理。
+            cur.next = pre;
+            // 原来的值先给出去。
+            pre = cur;
+            // 在处理自己的事情！！
+            cur = next;
+        }
+        return pre;
+    }
+
+    @Test
+    public void testR() {
+        ListNode head = new ListNode(1);
+        head.next = new ListNode(2);
+        head.next.next = new ListNode(3);
+        ListNode reverse = reverseByOther(head);
+        System.out.println(reverse);
+    }
+
+    ListNode reverse(ListNode head, ListNode b) {
+        ListNode pre, cur, next;
+        pre = null;
+        cur = head;
+        while (cur != b) {
+            next = cur.next;
+            cur.next = pre;
+            pre = cur;
+            cur = next;
+        }
+        return pre;
+    }
+
+    @Test
+    public void testK() {
+        int[] ints = {1,2,3,4,5};
+        final ListNode head = buildLinkedList(ints);
+        final ListNode listNode = reverseKGroup(head, 2);
+        log.info("{}", listNode);
+    }
+
+    // 每k个进行一个反转；
+    public ListNode reverseKGroup1(ListNode head, int k) {
+        if (head == null) {
+            return null;
+        }
+
+        ListNode a, b;
+        a = b = head;
+        for (int i = 0; i < k; i++) {
+            // 没有k的时候，直接返回。
+            // 要是也要进行呢？
+            if (b.next == null) {
+                break;
+            }
+            // 要是舍弃掉这个后续的元素呢？
+//            if (b == null) {
+//                return head;
+//            }
+            b = b.next;
+        }
+
+        ListNode newHead = reverse(a, b);
+        a.next = reverseKGroup1(b, k);
+        return newHead;
+    }
+
+    public ListNode partition(ListNode head, int x) {
+//        ListNode cur = head, newHead = new ListNode(-1), newPoint = newHead,
+//        greaterLink = new ListNode(-1), greatPoint = greaterLink;
+//        // 需要记录最后的数据。
+//        while (cur != null) {
+//            if (cur.val <  x) {
+//                newPoint.next = cur;
+//                newPoint = newPoint.next;
+//            } else {
+//                greatPoint.next = cur;
+//                greatPoint = greatPoint.next;
+//            }
+//            cur = cur.next;
+//        }
+//        ListNode last = newHead.next;
+//        while (last.next != null) {
+//            last = last.next;
+//        }
+//        last.next = greaterLink.next;
+//        return newHead.next;
+        ListNode small = new ListNode(0);
+        ListNode smallHead = small;
+        ListNode large = new ListNode(0);
+        ListNode largeHead = large;
+        while (head != null) {
+            if (head.val < x) {
+                small.next = head;
+                small = small.next;
+            } else {
+                large.next = head;
+                large = large.next;
+            }
+            head = head.next;
+        }
+        large.next = null;
+        small.next = largeHead.next;
+        return smallHead.next;
+    }
+
+    @Test
+    public void testPa() {
+        final ListNode listNode = buildLinkedList(new int[]{1, 4, 3, 2, 5, 2});
+        System.out.println(partition(listNode, 3));
+    }
+
+    @Test
+    public void testGroup() {
+        int[] arr = {1, 2, 3, 4, 5};
+        ListNode linkList = buildLinkedList(arr);
+        log.info("{}", linkList);
+    }
+
+    public ListNode buildLinkedList(int[] arr) {
+        if (arr == null || arr.length == 0) {
+            return null;
+        }
+
+        ListNode dummy = new ListNode(0);
+        ListNode current = dummy;
+
+        for (int value : arr) {
+            current.next = new ListNode(value);
+            current = current.next;
+        }
+
+        return dummy.next;
+    }
+
+    public ListNode mergeKLists(ListNode[] lists) {
+        return merge(lists, 0, lists.length - 1);
+    }
+
+    private ListNode merge(ListNode[] lists, int l, int r) {
+        if (l == r) {
+            return lists[l];
+        }
+        if (l > r) {
+            return null;
+        }
+        int mid = l + (r - l) / 2;
+        return mergeTwoLinkList(merge(lists, l, mid), merge(lists, mid + 1, r));
+    }
+
+    public ListNode mergeTwoLinkList(ListNode a, ListNode b) {
+        if (a == null || b == null) {
+            return a != null ? a : b;
+        }
+        ListNode head = new ListNode(0);
+        // 指针和一个链表的元素一定要搞清楚啊。
+        ListNode tail = head, aPtr = a, bPtr = b;
+        while (aPtr != null && bPtr != null) {
+            if (aPtr.val < bPtr.val) {
+                tail.next = aPtr;
+                aPtr = aPtr.next;
+            } else {
+                tail.next = bPtr;
+                bPtr = bPtr.next;
+            }
+            tail = tail.next;
+        }
+        tail.next = (aPtr != null ? aPtr : bPtr);
+        return head.next;
+    }
+
+    @Test
+    public void testMerge() {
+        ListNode head = buildLinkedList(new int[]{1, 2, 3, 3, 4, 4, 5});
+        ListNode head2 = buildLinkedList(new int[]{1, 1, 3, 4});
+        ListNode linkList = mergeTwoLinkList(head, head2);
+        log.info("{}", linkList);
+
+        int[][] ints = {{1, 4, 5}, {1, 3, 4}, {2, 6}};
+        ListNode[] list = new ListNode[3];
+        for (int[] anInt : ints) {
+
+        }
+    }
+
+
+    @Test
+    public void a() {
+        ListNode head = buildLinkedList(new int[]{1, 1, 2, 3, 3});
+//        LinkList linkList = deleteDuplicates(head);
+        ListNode linkListI = deleteDuplicatesI(head);
+        log.info("{}", linkListI);
+    }
+
+    /**
+     * 保留一个元素。
+     *
+     * @param head
+     * @return
+     */
+    public ListNode deleteDuplicatesI(ListNode head) {
+        ListNode dummy = new ListNode(-1);
+        dummy.next = head;
+        ListNode cur = dummy.next;
+        while (cur.next != null && cur != null) {
+            if (cur.val == cur.next.val) {
+                cur.next = cur.next.next;
+            } else {
+                cur = cur.next;
+            }
+        }
+
+        return dummy.next;
+    }
+
+    public ListNode reverseByPointer(ListNode head) {
+        ListNode pre, cur, next;
+        pre = null;
+        cur = head;
+        while (cur != null) {
+
+        }
+        return pre;
+    }
+
+    ListNode successor = null;
+
+    /**
+     * 需要有后续的接点
+     *
+     * @param b
+     * @param head
+     * @return
+     */
+    public ListNode reverseMe(int b, ListNode head) {
+        if (b == 1) {
+            successor = head.next;
+            return head;
+        }
+        ListNode reverse = reverseMe(b - 1, head.next);
+        head.next.next = head;
+        head.next = successor;
+        return reverse;
+    }
+
+    public ListNode reverseBetween(ListNode head, int left, int right) {
+        // base case
+        if (left == 1) {
+            return reverseMe(right, head);
+        }
+        // 前进到反转的起点触发 base case
+        head.next = reverseBetween(head.next, left - 1, right - 1);
+        return head;
+    }
+
+    ListNode reverseN(ListNode head, int n) {
+        if (n == 1) {
+            // 记录第 n + 1 个节点
+            successor = head.next;
+            return head;
+        }
+        // 以 head.next 为起点，需要反转前 n - 1 个节点
+        ListNode last = reverseN(head.next, n - 1);
+
+        head.next.next = head;
+        // 让反转之后的 head 节点和后面的节点连起来
+        head.next = successor;
+        return last;
+
+    }
+
+    @Test
+    public void testRMe() {
+        ListNode linkList = buildLinkedList(new int[]{1, 2, 3, 4, 5});
+        ListNode reverse = reverseBetween(linkList, 2, 4);
+        log.info("{}", reverse);
+    }
+
+    /**
+     * k个一组进行翻转。
+     *
+     * @param head
+     * @param k
+     * @return
+     */
+    public ListNode reverseKGroup(ListNode head, int k) {
+        if (k == 1) {
+            return head;
+        }
+        if (head == null) {
+            return null;
+        }
+        // 区间 [a, b) 包含 k 个待反转元素
+        ListNode a, b;
+        a = b = head;
+        for (int i = 0; i < k; i++) {
+            // 不足 k 个，不需要反转，base case
+            if (b == null) {
+                return head;
+            }
+            b = b.next;
+        }
+        // 反转前 k 个元素
+        ListNode newHead = reverse(a, b);
+        // 递归反转后续链表并连接起来
+        a.next = reverseKGroup(b, k);
+
+        return newHead;
+    }
+
+    /**
+     * 翻转a~b内的元素
+     * 左闭右开
+     *
+     * @param a
+     * @param b
+     * @return
+     */
+    public ListNode reverseII(ListNode a, ListNode b) {
+        ListNode pre, cur, next;
+        pre = null;
+        cur = a;
+        while (cur != b) {
+            next = cur.next;
+            cur.next = pre;
+            pre = cur;
+            cur = next;
+        }
+        return pre;
+    }
+
+    /**
+     * 保全自己
+     *
+     * @param head
+     * @return
+     */
+    public ListNode deleteDuplicates12(ListNode head) {
+
+        ListNode dummy = new ListNode(-1);
+        dummy.next = head;
+        ListNode cur = dummy;
+        while (cur.next != null && cur.next.next != null) {
+            if (cur.next.next != null && cur.next.val == cur.next.next.val) {
+                cur.next = cur.next.next;
+            } else {
+                cur = cur.next;
+            }
+        }
+        return dummy.next;
+    }
+
+    /**
+     * 全部删除
+     *
+     * @param head
+     * @return
+     */
+    public ListNode deleteDuplicates(ListNode head) {
+        ListNode dummy = new ListNode(-1);
+        dummy.next = head;
+        ListNode cur = dummy;
+        while (cur.next != null && cur.next.next != null) {
+            if (cur.next.next.val == cur.next.val) {
+                // 这一步很关键啊。会把自己也删除掉的。
+                int x = cur.next.val;
+                while (cur.next != null && cur.next.val == x) {
+                    cur.next = cur.next.next;
+                }
+            } else {
+                // 要是一直那么写就没有了选择，就是一个简单的指针了
+                cur = cur.next;
+            }
+        }
+        return dummy.next;
+    }
+
+    @Test
+    public void test12() {
+//        ListNode listNode = buildLinkedList(new int[]{1,2,3,3,4,4,5,6,6});
+        ListNode listNode = buildLinkedList(new int[]{1, 2, 3, 4, 5});
+        ListNode rotateRight = rotateRightSolution(listNode, 3);
+//        ListNode listNode1 = rightOneStep(listNode);
+        log.info("{}", rotateRight);
+    }
+
+    public ListNode rotateRight(ListNode head, int k) {
+        if (head == null || k == 0) {
+            return head;
+        }
+        ListNode inParam = head;
+        ListNode rotate = null;
+        for (int i = 0; i < k; i++) {
+            rotate = rightOneStep(inParam);
+            inParam = rotate;
+        }
+        return rotate;
+    }
+
+    public ListNode rightOneStep(ListNode node) {
+        ListNode last, pre = null;
+        ListNode cur = node;
+        while (cur.next != null) {
+            pre = cur;
+            cur = cur.next;
+        }
+        pre.next = null;
+        // 新的节点；
+        last = cur;
+        last.next = node;
+        return last;
+    }
+
+    /**
+     * 新链表的最后一个节点为原链表的第 (n−1)−(k%n)(n - 1) - (k \bmod n)(n−1)−(kmodn) 个节点（从 000 开始计数）。
+     *
+     * @param head
+     * @param k
+     * @return
+     */
+    public ListNode rotateRightSolution(ListNode head, int k) {
+        if (k == 0 || head == null || head.next == null) {
+            return head;
+        }
+        int n = 1;
+        ListNode iter = head;
+        while (iter.next != null) {
+            iter = iter.next;
+            n++;
+        }
+        int add = n - k % n;
+        if (add == n) {
+            return head;
+        }
+        // 环形。然后有？
+        iter.next = head;
+        while (add-- > 0) {
+            iter = iter.next;
+        }
+        ListNode ret = iter.next;
+        iter.next = null;
+        return ret;
+    }
+
+    /**
+     * 旋转数组。和上面的选择列表很像
+     *
+     * @param nums
+     * @param k
+     */
+    public void rotateMe(int[] nums, int k) {
+        if (k == 0) {
+            return;
+        }
+
+        int len = nums.length;
+        int move = k % len;
+        if (move == 0) {
+            return;
+        }
+        // 怎么解决覆盖的问题？？
+        for (int i = len - 1; i >= 0; i--) {
+            int temp = nums[i];
+            int index = (temp + k) % len;
+
+        }
+    }
+
+    @Test
+    public void testRotate() {
+        rotate(new int[]{1, 2, 3, 4, 5}, 3);
+    }
+
+    public void rotate(int[] nums, int k) {
+        int n = nums.length;
+        k = k % n;
+        // 2,5 ==> 1
+        int count = gcd(k, n);
+        for (int start = 0; start < count; ++start) {
+            int current = start;
+            int prev = nums[start];
+            do {
+                int next = (current + k) % n;
+                int temp = nums[next];
+                nums[next] = prev;
+                prev = temp;
+                current = next;
+            } while (start != current);
+        }
+    }
+
+    public int gcd(int x, int y) {
+        return y > 0 ? gcd(y, x % y) : x;
+    }
+
+    /**
+     * 和最大的连续子数组
+     * <p>
+     * dp的定义是什么？
+     * <p>
+     * 代表的是第i个位置处，前i-1的最大值。
+     * dp(i) = max(dp(i-1)+nums(i), dp(i-1))
+     * <p>
+     * 初始的情况是dp（i） = nums(i)；
+     * 上面描述的dp的定义是错误的！！
+     * <p>
+     * 实际上用的是
+     * dp_i = max(nums[i], dp_(i-1)+nums[i])
+     * </p>
+     *
+     * @param nums
+     * @return
+     */
+    public int maxSubArray(int[] nums) {
+        int n = nums.length;
+        int[] dp = new int[n];
+        dp[0] = nums[0];
+        for (int i = 1; i < nums.length; i++) {
+            // 这是序列的意思
+//            dp[i] = Math.max(dp[i-1]+nums[i], dp[i-1]);
+
+            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
+        }
+        log.info("{}", dp);
+        int res = Integer.MIN_VALUE;
+        for (int i = 0; i < n; i++) {
+            res = Math.max(res, dp[i]);
+        }
+        return res;
+    }
+
+    /**
+     * 更近一步的处理：压缩空间 因为有i 只和 i-1有关，所以有
+     *
+     * @param nums
+     * @return
+     */
+    public int maxSubArrayII(int[] nums) {
+        int n = nums.length;
+        if (n == 0) {
+            return 0;
+        }
+        int dp_0 = nums[0];
+        int dp_1 = 0, res = dp_0;
+        for (int i = 1; i < n; i++) {
+            dp_1 = Math.max(dp_0 + nums[i], nums[i]);
+            // dp_0 是上一步的值有一步的延迟；
+            dp_0 = dp_1;
+            res = Math.max(res, dp_1);
+        }
+        return res;
+    }
+
+    /**
+     * 此数组是一个环形的；可以首尾相连。
+     * <p>
+     * 有 n为他们的长度，这时有num[n] = nums[0];
+     * 用数学的表达式说明如下：
+     * <p>
+     * nums[i] = nums[i%n];
+     * 但是有一个问题不是说在之前的就会算数的。
+     * 只能包含数组一次。
+     * </p>
+     *
+     * @param nums
+     * @return
+     */
+    public int maxSubarraySumCircular(int[] nums) {
+        int n = nums.length;
+        int[] leftMax = new int[n];
+        // 对坐标为 0 处的元素单独处理，避免考虑子数组为空的情况
+        leftMax[0] = nums[0];
+        int leftSum = nums[0];
+        int pre = nums[0];
+        int res = nums[0];
+        for (int i = 1; i < n; i++) {
+            pre = Math.max(pre + nums[i], nums[i]);
+            res = Math.max(res, pre);
+            leftSum += nums[i];
+            leftMax[i] = Math.max(leftMax[i - 1], leftSum);
+        }
+
+        // 从右到左枚举后缀，固定后缀，选择最大前缀
+        int rightSum = 0;
+        for (int i = n - 1; i > 0; i--) {
+            rightSum += nums[i];
+            res = Math.max(res, rightSum + leftMax[i - 1]);
+        }
+        return res;
+    }
+
+    @Test
+    public void main() {
+        int[] nums = {5, -3, 5};
+        System.out.println(maxSubarraySumCircular(nums));
+    }
+
+
+    @Test
+    public void testSubArray() {
+        int[] nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
+        maxSubArray(nums);
+    }
+
+    public int findKthLargest(int[] nums, int k) {
+        if (k == 0 || nums == null || nums.length < k) {
+            return -1;
+        }
+
+        // 这个是一个快速排序的问题；
+        int n = nums.length;
+        int num = quickSort(nums, 0, n - 1, k);
+        return num;
+    }
+
+    public int quickSort(int[] nums, int left, int right, int k) {
+        if (k == 0) {
+            return nums[left];
+        }
+        return 0;
+    }
+
+    /**
+     * 从头删除第nth节点
+     *
+     * @param head
+     * @param n
+     * @return
+     */
+    public ListNode removeNthFromBegin(ListNode head, int n) {
+        if (head == null || n == 0) {
+            return head;
+        }
+        ListNode dummy = new ListNode(-1);
+        dummy.next = head;
+        ListNode cur = head;
+        for (int i = n - 2; i > 0; i--) {
+            cur = cur.next;
+        }
+        cur.next = cur.next.next;
+        return dummy.next;
+    }
+
+    // 主函数
+    public ListNode removeNthFromEnd(ListNode head, int n) {
+        // 虚拟头结点
+        ListNode dummy = new ListNode(-1);
+        dummy.next = head;
+        // 删除倒数第 n 个，要先找倒数第 n + 1 个节点
+        ListNode x = findFromEnd(dummy, n + 1);
+        // 删掉倒数第 n 个节点
+        x.next = x.next.next;
+        return dummy.next;
+    }
+
+    // 返回链表的倒数第 k 个节点
+    ListNode findFromEnd(ListNode head, int k) {
+        ListNode p1 = head;
+        // p1 先走 k 步
+        for (int i = 0; i < k; i++) {
+            p1 = p1.next;
+        }
+        ListNode p2 = head;
+        // p1 和 p2 同时走 n - k 步
+        while (p1 != null) {
+            p2 = p2.next;
+            p1 = p1.next;
+        }
+        // p2 现在指向第 n - k 个节点
+        return p2;
+    }
+
+
+    @Test
+    public void delete() {
+        ListNode listNode = buildLinkedList(new int[]{1, 2, 3, 4, 5});
+        val listNode1 = removeNthFromBegin(listNode, 4);
+        log.info("{}", listNode1);
+    }
+
+    /**
+     * 从头节点开始【旋转k次，可以看见值的大小】
+     *
+     * @param head
+     * @param k
+     * @return
+     */
+    public ListNode rotateRight1010(ListNode head, int k) {
+        if (head == null || k == 0 || head.next == null) {
+            return head;
+        }
+
+        // 计算几个节点
+        int cnt = 1;
+        while (head != null) {
+            cnt++;
+            head = head.next;
+        }
+        int res = cnt - k % cnt;
+        if (res == cnt) {
+            return head;
+        }
+        // 移动res个。什么情况呢？
+        ListNode cur = head;
+        while (cur.next != null) {
+            cur = cur.next;
+        }
+        cur.next = head;
+        while (res > 0) {
+            head = head.next;
+            res--;
+        }
+        // 断节点；
+        ListNode ret = cur.next;
+
+        return head;
+    }
+}
\ No newline at end of file
Index: common/core/src/main/java/org/example/common/core/leetcode/single/Singleton.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/single/Singleton.java b/common/core/src/main/java/org/example/common/core/leetcode/single/Singleton.java
new file mode 100644
--- /dev/null	(date 1698633783436)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/single/Singleton.java	(date 1698633783436)
@@ -0,0 +1,17 @@
+package org.example.common.core.leetcode.single;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:单例的实现类。有什么的缺点呢？
+ * @time: 2023/8/24 14:58
+ */
+public class Singleton {
+    private Singleton() {
+
+    }
+    private static Singleton instance = new Singleton();
+    public static Singleton getInstance(){
+        return instance;
+    }
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/single/SingleEnum.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/single/SingleEnum.java b/common/core/src/main/java/org/example/common/core/leetcode/single/SingleEnum.java
new file mode 100644
--- /dev/null	(date 1698633783434)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/single/SingleEnum.java	(date 1698633783434)
@@ -0,0 +1,14 @@
+package org.example.common.core.leetcode.single;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/8/24 15:44
+ */
+public enum SingleEnum {
+    INSTANCE;
+    public void single() {
+        System.out.println("operation");
+    }
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/link/Leet1020.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/link/Leet1020.java b/common/core/src/main/java/org/example/common/core/leetcode/link/Leet1020.java
new file mode 100644
--- /dev/null	(date 1698635984124)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/link/Leet1020.java	(date 1698635984124)
@@ -0,0 +1,121 @@
+package org.example.common.core.leetcode.link;
+
+import lombok.extern.slf4j.Slf4j;
+import org.junit.Test;
+
+import java.util.ArrayList;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/20 15:05
+ */
+@Slf4j
+public class Leet1020 {
+    /**
+     * 全部删除的情况。
+     *
+     * @param head
+     * @return
+     */
+    public ListNode deleteDup(ListNode head) {
+        final ListNode dummy = new ListNode(-1);
+        dummy.next = head;
+        /**这里是从虚拟的节点开始。
+         * */
+        ListNode cur = dummy;
+        while (cur.next != null && cur.next.next != null) {
+            if (cur.next.val == cur.next.next.val) {
+                int val = cur.next.val;
+                while (cur.next != null && val == cur.next.val) {
+                    // 没有删除掉自己
+                    cur.next = cur.next.next;
+                }
+            } else {
+                cur = cur.next;
+            }
+        }
+        return dummy.next;
+    }
+
+    /**
+     * 保留一个重复的元素。
+     *
+     * @param head
+     * @return
+     */
+    public ListNode deleteRemainOne(ListNode head) {
+        final ListNode dummy = new ListNode(-1);
+        dummy.next = head;
+        /**
+         * 这里的是从真实节点开始的。
+         * */
+        ListNode cur = head;
+        while (cur != null) {
+            int val = cur.val;
+            while (cur.next != null && val == cur.next.val) {
+                cur.next = cur.next.next;
+                // 没有删除掉自己
+            }
+            cur = cur.next;
+        }
+
+
+        return dummy.next;
+    }
+
+    /**
+     * 这时要求有要是有多个（大于2个的时候，要求保留2个重复元素呢？）
+     */
+
+    @Test
+    public void main() {
+        final SumLinkList sumLinkList = new SumLinkList();
+        final ListNode listNode = sumLinkList.buildLinkedList(new int[]{1, 1, 1, 2, 2, 3, 4, 5, 5});
+        // 1 2 2 3 4 5
+        final ListNode listNode1 = deleteRemainOne(listNode);
+//        final ListNode listNode1 = sumLinkList.deleteDuplicates(listNode);
+        log.info("{}", listNode1);
+    }
+
+
+    public ListNode rotateN() {
+        return null;
+    }
+
+    public static void main(String[] args) {
+        final ArrayList<Integer> list = new ArrayList<>();
+        final Integer item = new Integer(1);
+        list.remove(item);
+
+    }
+
+    @Test
+    public void testDu() {
+        int[] nums = {0,0,1,1,1,1,2,3,3};
+        System.out.println(removeDuplicatesSolution(nums));
+    }
+
+    /**
+     * 对于数组来说，要求保留2个元素，不要多留。
+     *
+     * @param nums
+     * @return
+     */
+    public int removeDuplicatesSolution(int[] nums) {
+        int n = nums.length;
+        if (n <= 2) {
+            return n;
+        }
+        int slow = 2, fast = 2;
+        while (fast < n) {
+            if (nums[slow - 2] != nums[fast]) {
+                nums[slow] = nums[fast];
+                ++slow;
+            }
+            ++fast;
+        }
+        return slow;
+    }
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/link/ListNode.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/link/ListNode.java b/common/core/src/main/java/org/example/common/core/leetcode/link/ListNode.java
new file mode 100644
--- /dev/null	(date 1698633783413)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/link/ListNode.java	(date 1698633783413)
@@ -0,0 +1,19 @@
+package org.example.common.core.leetcode.link;
+
+import lombok.Data;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/6/5 21:42
+ */
+@Data
+public class ListNode {
+    public int val;
+    public ListNode next;
+
+    public ListNode(Integer val) {
+        this.val = val;
+    }
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1030.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1030.java b/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1030.java
new file mode 100644
--- /dev/null	(date 1698980217037)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1030.java	(date 1698980217037)
@@ -0,0 +1,143 @@
+package org.example.common.core.leetcode.daily;
+
+import lombok.extern.slf4j.Slf4j;
+import org.junit.Test;
+
+import java.util.HashMap;
+import java.util.concurrent.*;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/30 10:43
+ */
+@Slf4j
+public class Leet1030 {
+    /**
+     * <B>已经是一个升序的队列。</B>
+     * <p>
+     * 由于研究者
+     * 1) 有3篇论文每篇 至少 被引用了 3 次，</br>
+     * 2) 其余两篇论文每篇被引用 不多于 3 次，</br>
+     * 所以她的 h 指数是 3 。
+     * 我的思想是正确的
+     * </p>
+     *
+     * @param citations
+     * @return
+     */
+    public int hIndexMe(int[] citations) {
+        if (citations == null) {
+            return -1;
+        }
+        int len = citations.length;
+        if (len == 1) {
+            return -1;
+        }
+        for (int i = 0; i < len; i++) {
+            // 什么情况要有更新的操作呢？0,1,3,5,6
+            int index = i + 1;
+            if (citations[i] < index) {
+                continue;
+            } else {
+                if (len - index < index) {
+                    return citations[i];
+                }
+            }
+        }
+        return -1;
+    }
+
+    @Test
+    public void main() {
+        int[] nums = {100};
+        System.out.println(hIndex(nums));
+    }
+
+    public int hIndex(int[] citations) {
+        int n = citations.length;
+        int left = 0, right = n - 1;
+        while (left <= right) {
+            int mid = left + (right - left) / 2;
+            // 其余两篇论文每篇被引用 不多于 3 次
+            if (citations[mid] >= n - mid) {
+                right = mid - 1;
+            } else {
+                // if (citations[i] < index) 等价于ci【i】 < index{
+                left = mid + 1;
+            }
+        }
+        return n - left;
+    }
+
+    /**
+     * 找出最多几套的QWER
+     * <B>有一个方法说明是表明是一套QWER的约束条件。要是一套。就记录下来left++；
+     * 要不是一套的话，就需要有【righ++】--
+     *
+     * </B>
+     *
+     * @param s
+     * @return
+     */
+    public int balancedString(String s) {
+        // 使用数组来存储四个字符的出现次数（使用数组便于代码书写）
+        int[] counts = new int[26];
+        int len = s.length();
+        int limit = len / 4;
+        char ch;
+        // 初始化不替换内容字符出现次数数组，即初始滑动窗口维护一个空串
+        for (int i = 0; i < len; i++) {
+            ch = s.charAt(i);
+            counts[ch - 'A']++;
+        }
+        // 初始化滑动窗口左右指针，维护的子串是[left,right]的内容
+        // 初始化子串为空，因此left=0，right=-1表示一个空子串
+        int left = 0;
+        int right = -1;
+        // 最小替换子串长度，初始为整个字符串长度
+        int minLength = len;
+        // 滑动窗口
+        while (left < len) {
+            // 校验通过
+            if (check(counts, limit)) {
+                // 记录当前合法子串的长度并更新最小长度
+                // 左指针右移，那么原本左指针指向的字符就变成不替换的内容，不替换内容多了一个字符，对应count数组中的值加1
+                minLength = Math.min(minLength, right - left + 1);
+                counts[s.charAt(left++) - 'A']++;
+                log.info("由于平衡，左指针推进 Q:{},w:{},e:{},r:{}，right:{}， left:{}", counts['Q' - 'A'], counts['W' - 'A'], counts['E' - 'A'], counts['R' - 'A'], right, left);
+            } else if (right < len - 1) {
+                // 当前子串不合法且右指针还没到头
+                // 右指针右移，移动后的右指针指向的字符变成了子串的内容，不替换的内容少了一个字符，对应count数组中的值减1
+                counts[s.charAt(++right) - 'A']--;
+                log.info("由于不平衡，右指针推进{Q:{},w:{},e:{},r:{}}", counts['Q' - 'A'], counts['W' - 'A'], counts['E' - 'A'], counts['R' - 'A']);
+            } else {
+                // 右指针到头，搜索结束
+                break;
+            }
+        }
+        return minLength;
+
+    }
+
+    /**
+     * 校验函数，校验当前counts中四个字符的出现次数是否都小于等于limit；
+     * 是返回true，否返回false
+     */
+    private boolean check(int[] counts, int limit) {
+        if (counts['Q' - 'A'] > limit || counts['W' - 'A'] > limit || counts['E' - 'A'] > limit || counts['R' - 'A'] > limit) {
+            return false;
+        }
+        return true;
+    }
+
+    @Test
+    public void testBalancedString() {
+        String s = "QWER";
+        System.out.println(balancedString(s));
+        final HashMap<String, String> map = new HashMap<>();
+        map.get("id");
+        ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(10);
+    }
+}
\ No newline at end of file
Index: common/core/src/main/java/org/example/common/core/design/FlyWeight.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/design/FlyWeight.java b/common/core/src/main/java/org/example/common/core/design/FlyWeight.java
new file mode 100644
--- /dev/null	(date 1698633783343)
+++ b/common/core/src/main/java/org/example/common/core/design/FlyWeight.java	(date 1698633783343)
@@ -0,0 +1,67 @@
+package org.example.common.core.design;
+
+
+import org.junit.Test;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description: 享元模式
+ * 典型的例子包括图形系统中的字符绘制，其中每个字符的字体和大小可以作为内部状态，而位置等属性可以作为外部状
+ * @time: 2023/9/2 16:24
+ */
+public class FlyWeight {
+
+    // 享元工厂类
+
+    /**
+     * <p>
+     * 在享元模式中，有两个关键的概念：
+     * 内部状态（Intrinsic State）：内部状态是可以被多个享元对象共享的状态，它通常是不变的，存储在享元对象内部。内部状态是享元对象的一部分，因此不会随每个对象的变化而变化。
+     * 外部状态（Extrinsic State）：外部状态是每个享元对象的特有状态，它不能被共享。外部状态存储在客户端代码中，而不是享元对象内部。
+     * 享元模式的距离取决于您的需求和项目的规模。在小型项目中，可能不太需要使用享元模式，
+     * 因为内存开销可能不是主要问题。但是，在处理大规模数据或需要频繁创建和销毁对象的情况下
+     * ，享元模式可以大幅减少内存占用，提高性能。因此，它更常用于需要优化内存和性能的大型应用程序或系统中。
+     * </p>
+     */
+    class StringFlyweightFactory {
+        private Map<String, StringFlyweight> flyweights = new HashMap<>();
+
+        public StringFlyweight getStringFlyweight(String value) {
+            if (!flyweights.containsKey(value)) {
+                flyweights.put(value, new StringFlyweight(value));
+            }
+            return flyweights.get(value);
+        }
+    }
+
+    // 享元类
+    class StringFlyweight {
+        private String value;
+
+        public StringFlyweight(String value) {
+            this.value = value;
+        }
+
+        public void printLocation(int x, int y) {
+            System.out.println("String '" + value + "' is located at (" + x + ", " + y + ")");
+        }
+    }
+
+    @Test
+    public void main() {
+        StringFlyweightFactory factory = new StringFlyweightFactory();
+
+        // 创建多个享元对象，共享相同的内部状态
+        StringFlyweight hello = factory.getStringFlyweight("Hello");
+        StringFlyweight world = factory.getStringFlyweight("World");
+
+        // 在不同位置使用这些享元对象的外部状态
+        hello.printLocation(10, 20);
+        world.printLocation(30, 40);
+        hello.printLocation(50, 60);
+    }
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/daily/LRUCache.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/daily/LRUCache.java b/common/core/src/main/java/org/example/common/core/leetcode/daily/LRUCache.java
new file mode 100644
--- /dev/null	(date 1698633783378)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/daily/LRUCache.java	(date 1698633783378)
@@ -0,0 +1,52 @@
+package org.example.common.core.leetcode.daily;
+
+import java.util.HashMap;
+import java.util.Hashtable;
+import java.util.LinkedHashMap;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:lru缓存，它应该删除最近最少使用的项目。
+ * @time: 2023/9/3 12:23
+ */
+public class LRUCache {
+    Hashtable<String, Integer> map = new Hashtable<>();
+    HashMap<String, Integer> map1 = new HashMap<>();
+    int cap;
+    LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();
+    public LRUCache(int capacity) {
+        this.cap = capacity;
+    }
+
+    public int get(int key) {
+        if (!cache.containsValue(key)) {
+            return -1;
+        }
+        // key为最近使用。
+        makeRecent(key);
+        return cache.get(key);
+    }
+
+    private void makeRecent(int key) {
+        //加入到最后。
+        int value = cache.get(key);
+        cache.remove(key);
+        cache.put(key, value);
+    }
+
+    public void put(int key, int value) {
+        if (cache.containsValue(key)) {
+            //
+            cache.put(key, value);
+            makeRecent(key);
+            return;
+        }
+        if (cache.size() >  cap) {
+            int old = cache.keySet().iterator().next();
+            cache.remove(old);
+        }
+        // key放入
+        cache.put(key, value);
+    }
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/Leetcode1234.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.example.common.core.leetcode;\r\n\r\nimport org.junit.Test;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.stream.Collectors;\r\n\r\n/**\r\n * @Author: lejun\r\n * @project: cloud\r\n * @description:\r\n * @time: 2023/2/13 21:15\r\n */\r\npublic class Leetcode1234 {\r\n\r\n    @Test\r\n    public void min() {\r\n        int qqwe = balancedStringAnswer(\"QQWE\");\r\n        System.out.println(qqwe);\r\n    }\r\n\r\n    public int balancedStringAnswer(String s) {\r\n        int[] cnt = new int[26];\r\n        for (int i = 0; i < s.length(); i++) {\r\n            char c = s.charAt(i);\r\n            cnt[idx(c)]++;\r\n        }\r\n\r\n        int partial = s.length() / 4;\r\n        int res = s.length();\r\n\r\n        if (check(cnt, partial)) {\r\n            return 0;\r\n        }\r\n        for (int l = 0, r = 0; l < s.length(); l++) {\r\n            while (r < s.length() && !check(cnt, partial)) {\r\n                cnt[idx(s.charAt(r))]--;\r\n                r++;\r\n            }\r\n            if (!check(cnt, partial)) {\r\n                break;\r\n            }\r\n            res = Math.min(res, r - l);\r\n            cnt[idx(s.charAt(l))]++;\r\n        }\r\n        return res;\r\n    }\r\n    /**\r\n     * {Q,W,E,R}四种字符，要求要平衡，就是说的/4的操作。\r\n     * <p>\r\n     * QQER--> 1 qq er\r\n     * QWER--> 0\r\n     *\r\n     * </p>\r\n     *\r\n     * <p>\r\n     *     answer:先固定左指针，右指针向右移动，得到的是以当前左指针为左边界的最小区间，\r\n     *     这时候可以固定右边界改变左边界位置，向右移动左指针，在移动左指针的过程中，\r\n     *     如果区间仍满足要求，那么该区间一定是以当前左指针为左边界的最小区间，\r\n     *     如果不满足要求就固定左边界，继续改变右边界\r\n     * </p>\r\n     * @param s\r\n     * @return\r\n     */\r\n    public int balancedString(String s) {\r\n        int step = 0;\r\n        int n = s.length();\r\n        // todo\r\n        int[] chars = new int[26];\r\n        for (char item : s.toCharArray()) {\r\n            chars[item - 'A']++;\r\n        }\r\n        int part = n / 4;\r\n        int left = 0, right = 0;\r\n        // 左右滑动窗口的处理是\r\n        for (int l = 0, r = 0; l < s.length(); l++) {\r\n            while (r < s.length() && !check(chars, part)) {\r\n                chars[idx(s.charAt(r))]--;\r\n                r++;\r\n            }\r\n            if (!check(chars, part)){\r\n                break;\r\n            }\r\n            step = Math.min(step, r-l);\r\n            chars[idx(s.charAt(l))]++;\r\n        }\r\n        return step;\r\n    }\r\n\r\n    public boolean check(int[] cnt, int partial) {\r\n        if (cnt[idx('Q')] > partial || cnt[idx('W')] > partial || cnt[idx('E')] > partial || cnt[idx('R')] > partial) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int idx(char c) {\r\n        return c - 'A';\r\n    }\r\n\r\n    @Test\r\n    public void main() {\r\n        // 想要对其中的几个字段进行处理，其实就是map(e-> new HashMap(){{put();put()}})\r\n        List<Map<String, Object>> maps = new ArrayList<>();\r\n        maps.add(new HashMap<String, Object>(){{put(\"id\", 1);put(\"name\", \"lejun\");}});\r\n        maps.add(new HashMap<String, Object>(){{put(\"id\", 2);put(\"name\", \"zjl\");}});\r\n        List<HashMap<String, Object>> collect = maps.stream().map(e ->\r\n                        new HashMap<String, Object>() {{\r\n                            put(\"id\", e.get(\"id\"));\r\n                        }})\r\n                .collect(Collectors.toList());\r\n        System.out.println(collect);\r\n\r\n\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/Leetcode1234.java b/common/core/src/main/java/org/example/common/core/leetcode/Leetcode1234.java
--- a/common/core/src/main/java/org/example/common/core/leetcode/Leetcode1234.java	(revision cf8ea38fa9da362ec8a79646980a64be2e30bae6)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/Leetcode1234.java	(date 1698637362341)
@@ -1,5 +1,6 @@
 package org.example.common.core.leetcode;
 
+
 import org.junit.Test;
 
 import java.util.ArrayList;
@@ -22,6 +23,12 @@
         System.out.println(qqwe);
     }
 
+    /**
+     * 获取平衡的要求，是要找出最少有几套QWER;
+     *
+     * @param s
+     * @return
+     */
     public int balancedStringAnswer(String s) {
         int[] cnt = new int[26];
         for (int i = 0; i < s.length(); i++) {
@@ -40,6 +47,7 @@
                 cnt[idx(s.charAt(r))]--;
                 r++;
             }
+            // 思想是什么？
             if (!check(cnt, partial)) {
                 break;
             }
Index: common/core/src/main/java/org/example/common/core/leetcode/dp/MinJump.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/dp/MinJump.java b/common/core/src/main/java/org/example/common/core/leetcode/dp/MinJump.java
new file mode 100644
--- /dev/null	(date 1698633783403)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/dp/MinJump.java	(date 1698633783403)
@@ -0,0 +1,377 @@
+package org.example.common.core.leetcode.dp;
+
+import lombok.extern.slf4j.Slf4j;
+import org.junit.Test;
+
+import java.util.*;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/8/30 21:19
+ */
+@Slf4j
+public class MinJump {
+    public int minimumJumps(int[] forbidden, int a, int b, int x) {
+        // 太难了。不能处理
+        return 0;
+    }
+
+    /**
+     * 机器人的路径有多少条？
+     *
+     * @param obstacleGrid
+     * @return
+     */
+    public int unquePathWithObstacles(int[][] obstacleGrid) {
+        int row = obstacleGrid.length;
+        int col = obstacleGrid[0].length;
+        int[][] mem = new int[row][col];
+        for (int i = 0; i < row; i++) {
+            Arrays.fill(mem[i], -1);
+        }
+        int res = 0;
+        int count = dfsUnique(obstacleGrid, 0, 0, mem);
+        log.info("{}", count);
+        return res;
+    }
+
+    public boolean dfs(int[][] grid, int c, int r, int res) {
+        if (c == grid.length - 1 && r == grid[0].length - 1) {
+            res++;
+            return true;
+        }
+        if (c >= grid.length || r >= grid[0].length || grid[c][r] == 1) {
+            return false;
+        }
+        if (dfs(grid, c++, r, res)) {
+            return true;
+        }
+        if (dfs(grid, c, r++, res)) {
+            return true;
+        }
+        grid[c][r] = 1;
+        return false;
+    }
+
+    @Test
+    public void test() {
+        int[][] obs = {{0, 0, 0}, {0, 1, 0}, {0, 0, 0}};
+        System.out.println(unquePathWithObstacles(obs));
+    }
+
+    private int dfsUnique(int[][] grid, int c, int r, int[][] mem) {
+        if (c == grid.length - 1 && r == grid[0].length - 1) {
+            return 1;
+        }
+        if (c >= grid.length || r >= grid[0].length || grid[c][r] == 1) {
+            return 0;
+        }
+        int total = 0;
+        if (mem[c][r] != -1) {
+            return mem[c][r];
+        }
+        total += dfsUnique(grid, c++, r, mem);
+        total += dfsUnique(grid, c, r++, mem);
+        mem[c][r] = total;
+        return total;
+    }
+// 最优的子结构是说的什么呢？
+
+    /**
+     * 最长的回文子序列的实现有：
+     * int longestPalindromeSubseq(String s) {
+     * int n = s.length();
+     * // base case：一维 dp 数组全部初始化为 1
+     * int[] dp = new int[n];
+     * Arrays.fill(dp, 1);
+     * <p>
+     * for (int i = n - 2; i >= 0; i--) {
+     * int pre = 0;
+     * for (int j = i + 1; j < n; j++) {
+     * int temp = dp[j];
+     * // 状态转移方程
+     * if (s.charAt(i) == s.charAt(j))
+     * dp[j] = pre + 2;
+     * else
+     * dp[j] = Math.max(dp[j], dp[j - 1]);
+     * pre = temp;
+     * }
+     * }
+     * return dp[n - 1];
+     * }
+     */
+    int longestPalindromeSubseq(String s) {
+        int n = s.length();
+        // base case：一维 dp 数组全部初始化为 1
+        int[] dp = new int[n];
+        Arrays.fill(dp, 1);
+
+        for (int i = n - 2; i >= 0; i--) {
+            int pre = 0;
+            for (int j = i + 1; j < n; j++) {
+                int temp = dp[j];
+                // 状态转移方程
+                if (s.charAt(i) == s.charAt(j)) {
+                    dp[j] = pre + 2;
+                } else {
+                    dp[j] = Math.max(dp[j], dp[j - 1]);
+                }
+                pre = temp;
+            }
+        }
+        return dp[n - 1];
+    }
+
+    public void twodp(String str) {
+        int n = str.length();
+        char[] s = str.toCharArray();
+        for (int i = n - 2; i >= 0; i--) {
+            for (int j = i + 1; j < n; j++) {
+                if (s[i] == s[j]) {
+                    // dp[i][j] = dp[i+1][j-1] +2;
+                } else {
+                    // dp[i][j] = max(dp[i+1][j], dp[i][j-1])
+                }
+            }
+        }
+    }
+
+    /**
+     * 最长公共前缀
+     *
+     * @param strs
+     * @return
+     */
+    public String longestCommonPrefix(String[] strs) {
+        if(strs == null || strs.length == 0) {
+            return "";
+        }
+        int n =  strs[0].length();
+        int len = strs.length;
+        for (int i = 0; i < n; i++) { // n
+            for (int j = 1; j < len; j++) { // len O(mn)
+                String thisStr = strs[j];
+                String preStr = strs[j - 1];
+                // 判断每个字符串的 col 索引是否都相同
+                if (i >= thisStr.length() || j >= preStr.length() ||
+                        thisStr.charAt(i) != preStr.charAt(i)) {
+                    // 发现不匹配的字符，只有 strs[row][0..col-1] 是公共前缀
+                    return strs[j].substring(0, i);
+                }
+            }
+        }
+        return "";
+    }
+
+    @Test
+    public void longTest() {
+        String[] strings = {"flower","flow","flight"};
+        longestCommonPrefix(strings);
+    }
+
+    /**
+     * 第一次出现的下标
+     *
+     * @param str
+     * @param needle
+     * @return
+     */
+    public int firstAppearIndex(String str, String needle) {
+        char[] ss = str.toCharArray();
+        char[] nn = needle.toCharArray();
+        int m = ss.length;
+        int n = needle.length();
+        for (int i = 0; i < m-n; i++) {
+            int a = i, b = 0;
+            while (ss[a] == nn[b] && b<n) {
+                b++;
+                a++;
+            }
+            if (b == n) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    @Test
+    public void testLong() {
+        String s = "0P";
+        String s1 = s.replaceAll("[^a-zA-Z]", "").toLowerCase();
+        log.info("{}",s1);
+        System.out.println(1/2);
+    }
+
+    public boolean isHuiWen(String s) {
+        // even 6 ==> 3  7 ==> 3;
+        int length = s.length();
+        for (int i = 0; i <= length/2; i++) {
+            if (s.charAt(i) != s.charAt(length-1 - i)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    @Test
+    public void testHuiwen() {
+        boolean palindrome = isPalindrome("0P");
+        System.out.println(palindrome);
+    }
+
+    public boolean isPalindrome(String s) {
+        StringBuffer sgood = new StringBuffer();
+        int length = s.length();
+        for (int i = 0; i < length; i++) {
+            char ch = s.charAt(i);
+            if (Character.isLetterOrDigit(ch)) {
+                sgood.append(Character.toLowerCase(ch));
+            }
+        }
+        int n = sgood.length();
+        int left = 0, right = n - 1;
+        while (left < right) {
+            if (Character.toLowerCase(sgood.charAt(left)) != Character.toLowerCase(sgood.charAt(right))) {
+                return false;
+            }
+            ++left;
+            --right;
+        }
+        return true;
+    }
+
+    // 要的是小写的字母和数字的，不是说就一个小写字母。
+    private boolean isValid(char c){
+        return (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9');
+    }
+
+    public boolean isSubsequence(String s, String t) {
+        if(t == null) {
+            return false;
+        }
+        if(s.length() == 0 && t.length() == 0) {
+            return true;
+        }
+        // 利用栈
+        Deque<Character> stack = new ArrayDeque<>();
+        for (int i = s.length()-1; i >= 0; i--) {
+            stack.push(s.charAt(i));
+        }
+        for (char c : t.toCharArray()) {
+            if (!stack.isEmpty() &&stack.peek() ==  c) {
+                stack.pop();
+            }
+        }
+        return stack.isEmpty();
+    }
+
+    @Test
+    public void main() {
+        isSubsequence("", "");
+    }
+
+    /**
+     *
+     * 最长的字串。
+     *
+     * @param s
+     * @return
+     */
+    public int lengthOfLongestSubstring(String s) {
+        Map<Character, Integer> map = new HashMap<>();
+        int left = 0, right = 0, res = 0;
+        while (right < s.length()) {
+            char c = s.charAt(right);
+            map.put(c, map.getOrDefault(c, 0) + 1);
+            right++;
+            // 判断是否是进行一个收缩。
+            while (map.get(c) > 1) {
+                char d = s.charAt(left);
+                left++;
+                map.put(d, map.get(d) -1);
+            }
+            // 更新答案；
+            res = Math.max(res, right - left);
+        }
+        return res;
+    }
+
+    /**
+     * 定义是什么？dp
+     * 初始状态：
+     * 转移的方程：
+     *
+     * @param nums
+     * @return
+     */
+    public boolean canJump(int[] nums) {
+        if (nums.length == 1) {
+            return true;
+        }
+        int len = nums.length;
+        boolean[] dp = new boolean[len];
+        for (int i = 0; i < len; i++) {
+            int maxJump = nums[i];
+
+        }
+        return dp[len - 1];
+    }
+
+    /**
+     * 最小的跳跃次数。
+     *
+     * @param nums
+     * @return
+     */
+    public int jump(int[] nums) {
+        int n = nums.length;
+        int end = 0, farthest = 0;
+        int jumps = 0;
+        for (int i = 0; i < n - 1; i++) {
+            farthest = Math.max(nums[i] + i, farthest);
+            if (end == i) {
+                jumps++;
+                end = farthest;
+            }
+        }
+        return jumps;
+    }
+
+    @Test
+    public void testMinJump() {
+        int[] nums = {2,3,0,1,4};
+        System.out.println(jump(nums));
+    }
+
+    public String longestPalindrome(String s) {
+        String res = "";
+        for (int i = 0; i < s.length(); i++) {
+            // 以 s[i] 为中心的最长回文子串
+            String s1 = palindrome(s, i, i);
+            // 以 s[i] 和 s[i+1] 为中心的最长回文子串
+            String s2 = palindrome(s, i, i + 1);
+            // res = longest(res, s1, s2)
+            res = res.length() > s1.length() ? res : s1;
+            res = res.length() > s2.length() ? res : s2;
+        }
+        return res;
+    }
+
+    String palindrome(String s, int l, int r) {
+        // 防止索引越界
+        while (l >= 0 && r < s.length()
+                && s.charAt(l) == s.charAt(r)) {
+            // 向两边展开
+            l--;
+            r++;
+        }
+        // 返回以 s[l] 和 s[r] 为中心的最长回文串
+        return s.substring(l + 1, r);
+    }
+
+    public static void main(String[] args) {
+        
+    }
+}
\ No newline at end of file
Index: common/core/src/main/java/org/example/common/core/leetcode/tree/Flatten.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/tree/Flatten.java b/common/core/src/main/java/org/example/common/core/leetcode/tree/Flatten.java
new file mode 100644
--- /dev/null	(date 1698633783452)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/tree/Flatten.java	(date 1698633783452)
@@ -0,0 +1,560 @@
+package org.example.common.core.leetcode.tree;
+
+import cn.hutool.core.util.ObjectUtil;
+import lombok.extern.slf4j.Slf4j;
+import org.junit.Test;
+
+import java.util.*;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/8/22 16:07
+ * 面试的加油哦，乐俊，既然要吃着一碗饭，有了牵挂，那就加油，不要做那些
+ * 无畏的事情了，HZ的事情还有人，真的有点low的。
+ */
+@Slf4j
+public class Flatten {
+
+    /**
+     * 最近的公共祖先是什么意思呢？
+     * [图片实例](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)
+     * <p>
+     *      1,p 和 q 分别在节点 node 的左右子树中。
+     *      2,node 即为节点 p，q 在节点 p 的左子树或右子树中。
+     *      3,node 即为节点 q，p 在节点 q 的左子树或者右子树中。
+     * </p>
+     *
+     * @param root
+     * @param p
+     * @param q
+     * @return
+     */
+    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
+        if (root == null || p == root || q == root) {
+            return root;
+        }
+        TreeNode left = lowestCommonAncestor(root.left, p, q);
+        TreeNode right = lowestCommonAncestor(root.right, p, q);
+        if (left == null && right == null) {
+            return null;
+        }
+        if (left == null) {
+            return right;
+        }
+        if (right == null) {
+            return left;
+        }
+        return root;
+    }
+
+    /**
+     * Z形状的遍历。有一个控制方向的变量
+     *
+     * @param root
+     * @return
+     */
+    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
+        if (root == null) {
+            return new ArrayList<>();
+        }
+        int level = 1;
+        List<List<Integer>> result = new ArrayList<>();
+        Deque<TreeNode> queue = new ArrayDeque<>();
+        queue.add(root);
+        while (!queue.isEmpty()) {
+            List<Integer> itemList = new ArrayList<>();
+            TreeNode item = queue.pop();
+            itemList.add(item.val);
+            if (level % 2 == 0) {
+                if (item.left != null) {
+                    queue.add(item.left);
+                }
+                if (item.right != null) {
+                    queue.add(item.right);
+                }
+            } else {
+                if (item.right != null) {
+                    queue.add(item.right);
+                }
+                if (item.left != null) {
+                    queue.add(item.left);
+                }
+            }
+            level++;
+        }
+        return result;
+    }
+
+    public List<List<Integer>> zigzagLevelOrderSolution(TreeNode root) {
+        if (root == null) {
+            return new ArrayList<>();
+        }
+        boolean reverseFlag = false;
+        List<List<Integer>> result = new LinkedList<List<Integer>>();
+        Deque<TreeNode> queue = new ArrayDeque<>();
+        queue.add(root);
+        while (!queue.isEmpty()) {
+            Deque<Integer> itemList = new LinkedList<>();
+            int size = queue.size();
+            for (int i = 0; i < size; i++) {
+                TreeNode item = queue.poll();
+                // 什么情况是要反转呢？
+                if (reverseFlag) {
+                    itemList.offerLast(item.val);
+                } else {
+                    itemList.offerFirst(item.val);
+                }
+                if (item.left != null) {
+                    queue.add(item.left);
+                }
+                if (item.right != null) {
+                    queue.add(item.right);
+                }
+            }
+            result.add(new LinkedList<Integer>(itemList));
+            reverseFlag = !reverseFlag;
+
+        }
+        return result;
+    }
+
+    public List<List<Integer>> LevelOrder(TreeNode root) {
+        if (root == null) {
+            return new ArrayList<>();
+        }
+        List<List<Integer>> result = new LinkedList<List<Integer>>();
+        Deque<TreeNode> queue = new ArrayDeque<>();
+        queue.add(root);
+        while (!queue.isEmpty()) {
+            Deque<Integer> itemList = new LinkedList<>();
+            int size = queue.size();
+            for (int i = 0; i < size; i++) {
+                TreeNode item = queue.poll();
+                // 什么情况是要反转呢？
+                if (ObjectUtil.isEmpty(item)) {
+                    itemList.offerLast(null);
+                } else {
+                    itemList.offerLast(item.val);
+                }
+                queue.add(item.left);
+                if (item.left != null) {
+
+                }
+                queue.add(item.right);
+                if (item.right != null) {
+                }
+            }
+            result.add(new LinkedList<Integer>(itemList));
+
+        }
+        return result;
+    }
+
+    public TreeNode buildTree(Integer[] arr) {
+        if (arr == null || arr.length == 0 || arr[0] == null) {
+            return null;
+        }
+
+        return buildTreeHelper(arr, 0);
+    }
+
+    private TreeNode buildTreeHelper(Integer[] arr, int index) {
+        if (index >= arr.length || arr[index] == null) {
+            return null;
+        }
+
+        TreeNode root = new TreeNode(arr[index]);
+
+        root.left = buildTreeHelper(arr, 2 * index + 1);
+        root.right = buildTreeHelper(arr, 2 * index + 2);
+
+        return root;
+    }
+
+    @Test
+    public void main() {
+        Integer[] arr = {5,3,6,2,4,null,null,1};
+        TreeNode root = buildTree(arr);
+//        List<List<Integer>> lists = levelOrder(root);
+//        log.info("{}", lists);
+    }
+
+    public List<List<Integer>> levelOrderWithNull(TreeNode root) {
+        List<List<Integer>> result = new ArrayList<>();
+        if (root == null) {
+            return result;
+        }
+
+        Queue<TreeNode> queue = new LinkedList<>();
+        queue.offer(root);
+
+        while (!queue.isEmpty()) {
+            int levelSize = queue.size();
+            List<Integer> currentLevel = new ArrayList<>();
+
+            for (int i = 0; i < levelSize; i++) {
+                TreeNode node = queue.poll();
+                if (node != null) {
+                    currentLevel.add(node.val);
+                    queue.offer(node.left);
+                    queue.offer(node.right);
+                } else {
+                    currentLevel.add(null);
+                }
+            }
+
+            // 只有当前层有非null值时才加入结果
+            if (!currentLevel.isEmpty()) {
+                result.add(currentLevel);
+            }
+        }
+
+        return result;
+    }
+
+    /**
+     * 先序遍历的第k个。但是有可以用二分法获取到吧。
+     * <p>
+     * 先序：是二叉树遍历中的一种，即先访问根结点，然后遍历左子树，后遍历右子树。遍历左、右子树时，先访问根结点，后遍历左子树，后遍历右子树，如果二叉树为空则返回。
+     *根左右
+     * 中序：是二叉树遍历中的一种，即先遍历左子树，后访问根结点，然后遍历右子树。若二叉树为空则结束返回。
+     *左根右
+      * 后序：是二叉树遍历中的一种，即先遍历左子树，后遍历右子树，然后访问根结点，遍历左、右子树时，仍先遍历左子树，后遍历右子树，最后遍历根结点。
+     *左右根
+     * </p>
+     *
+     * 还有普通的数的问题。
+     * @param root
+     * @param k
+     * @return
+     */
+    public int kthSmallest(TreeNode root, int k) {
+        if (root == null) {
+            return -1;
+        }
+        // 首先判出左子树的长度
+        Deque<TreeNode> stack = new ArrayDeque<>();
+        while (root != null || !stack.isEmpty()) {
+            while (root != null) {
+                stack.push(root);
+                root = root.left;
+            }
+            root = stack.pop();
+            --k;
+            if (k == 0) {
+                break;
+            }
+            root = root.right;
+        }
+        return root.val;
+    }
+
+    @Test
+    public void mainValid() {
+        Integer[] arr = {2,1,3};
+        Integer[] arr2 = {5,1,4,null,null,3,6};
+        TreeNode root = buildTree(arr2);
+//        System.out.println(isValidBST(root));
+
+    }
+
+    public int[][] insert(int[][] intervals, int[] newInterval) {
+        int[][] res = new int[intervals.length + 1][2];
+        int idx = 0;
+        // 遍历区间列表：
+        // 首先将新区间左边且相离的区间加入结果集
+        int i = 0;
+        while (i < intervals.length && intervals[i][1] < newInterval[0]) {
+            res[idx++] = intervals[i++];
+        }
+        // 接着判断当前区间是否与新区间重叠，重叠的话就进行合并，直到遍历到当前区间在新区间的右边且相离，
+        // 将最终合并后的新区间加入结果集
+        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {
+            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);
+            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);
+            i++;
+        }
+        res[idx++] = newInterval;
+        // 最后将新区间右边且相离的区间加入结果集
+        while (i < intervals.length) {
+            res[idx++] = intervals[i++];
+        }
+
+        return Arrays.copyOf(res, idx);
+    }
+
+    @Test
+    public void testI() {
+        int[][] ints= {{1,3}, {6,9}};
+        int[] newI = {2, 5};
+        insert(ints, newI);
+    }
+
+    /**
+     * 合并区间
+     *
+     * @param intervals
+     * @return
+     */
+    public int[][] merge(int[][] intervals) {
+        // 先按照区间起始位置排序
+        Arrays.sort(intervals, (v1, v2) -> v1[0] - v2[0]);
+        // 遍历区间
+        int[][] res = new int[intervals.length][2];
+        int idx = -1;
+        for (int[] interval: intervals) {
+            // 如果结果数组是空的，或者当前区间的起始位置 > 结果数组中最后区间的终止位置，
+            // 则不合并，直接将当前区间加入结果数组。
+            if (idx == -1 || interval[0] > res[idx][1]) {
+                res[++idx] = interval;
+            } else {
+                // 反之将当前区间合并至结果数组的最后区间
+                res[idx][1] = Math.max(res[idx][1], interval[1]);
+            }
+        }
+        return Arrays.copyOf(res, idx + 1);
+    }
+
+    @Test
+    public void mergeTest() {
+        int[][] ints = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};
+        int[][] merge = merge(ints);
+        log.info("{}", Arrays.deepToString(merge));
+    }
+
+    /**
+     * s 仅由括号 '()[]{}' 组成
+     *  <p>
+     *      遇到左括号就入栈，遇到右括号就去栈中寻找最近的左括号，
+     *      看是否匹配。
+     *  </p>
+     * @param s
+     * @return
+     */
+    public boolean isValid(String s) {
+        Deque<Character> stack = new ArrayDeque<>();
+        for (char c : s.toCharArray()) {
+            if (c == '(' || c == '{' || c== '[') {
+                stack.push(c);
+            } else {
+                // 可能会出现这个情况。
+                if (!stack.isEmpty() && stack.peek() == leftOf(c)) {
+                    stack.pop();
+                } else {
+                    return false;
+                }
+            }
+        }
+        return stack.isEmpty();
+    }
+
+    char leftOf(char c) {
+        if (c == '}') {
+            return '{';
+        }
+        if (c == ')') {
+            return '(';
+        }
+        return '[';
+    }
+
+    /**
+     * 镜像树的生成
+     *
+     * @param root
+     * @return
+     */
+    public TreeNode invertTree(TreeNode root) {
+        if (root == null) {
+            return null;
+        }
+        TreeNode leftNode = root.left;
+        TreeNode temp = leftNode;
+        TreeNode rightNode = root.right;
+
+        root.left = rightNode;
+        root.right = temp;
+        if (root.left != null) {
+            invertTree(root.left);
+        }
+        if (root.right != null) {
+            invertTree(root.right);
+        }
+        return root;
+    }
+
+    @Test
+    public void reverse() {
+        // Integer[] ints = {3,9,20,null,null,15,7};
+        Integer[] a = {3,9,20,null,null,15,7};
+        TreeNode treeNode = buildTree(a);
+        TreeNode root = null;
+//        TreeNode reverseNode = invertTree(treeNode);
+        List<List<Integer>> lists = levelOrderWithNullLastLevel(treeNode);
+        log.info("{}", lists);
+    }
+
+    public List<List<Integer>> levelOrderWithNullLastLevel(TreeNode root) {
+        List<List<Integer>> result = new ArrayList<>();
+        if (root == null) {
+            return result;
+        }
+
+        Queue<TreeNode> queue = new LinkedList<>();
+        queue.offer(root);
+
+        while (!queue.isEmpty()) {
+            int levelSize = queue.size();
+            List<Integer> currentLevel = new ArrayList<>();
+
+            for (int i = 0; i < levelSize; i++) {
+                TreeNode node = queue.poll();
+                if (node != null) {
+                    currentLevel.add(node.val);
+                    queue.offer(node.left);
+                    queue.offer(node.right);
+                } else {
+                    currentLevel.add(null);
+                }
+            }
+
+            result.add(currentLevel);
+        }
+        return result.subList(0,result.size() - 1);
+    }
+
+    /**
+     * 对称的树。还有的是什么？
+     *
+     * @param root
+     * @return
+     */
+    public boolean isSymmetric(TreeNode root) {
+        if (root == null) {
+            return true;
+        }
+        return dfs(root.left, root.right);
+    }
+
+    private boolean dfs(TreeNode left, TreeNode right) {
+        if (left == null && right == null) {
+            return true;
+        }
+        if (left == null || right == null) {
+            return false;
+        }
+        if (left.val != right.val){
+            return false;
+        }
+        return dfs(left.left, right.right) && dfs(left.right, right.left);
+    }
+
+    // 还有的是什么呢？需要做的是
+    public void setZeroes(int[][] matrix) {
+        int m = matrix.length, n = matrix[0].length;
+        boolean flagCol0 = false;
+        for (int i = 0; i < m; i++) {
+            if (matrix[i][0] == 0) {
+                flagCol0 = true;
+            }
+            for (int j = 1; j < n; j++) {
+                if (matrix[i][j] == 0) {
+                    matrix[i][0] = matrix[0][j] = 0;
+                }
+            }
+        }
+        for (int i = m - 1; i >= 0; i--) {
+            for (int j = 1; j < n; j++) {
+                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
+                    matrix[i][j] = 0;
+                }
+            }
+            if (flagCol0) {
+                matrix[i][0] = 0;
+            }
+        }
+    }
+
+    @Test
+    public void test() {
+        int[][] ints =  {{1,1,1},{1,0,1},{1,1,1}};
+        int[][] int2 = {{0,1,2,0},{3,4,5,2},{1,3,1,5}};
+        setZeroes(int2);
+        log.info("{}", int2);
+    }
+
+    /**
+     * 整数转罗马
+     * <p>
+     *     10
+     *     5
+     *     100
+     *
+     * </p>
+     * @param num
+     * @return
+     */
+    public String intToRoman(int num) {
+        StringBuffer stringBuffer = new StringBuffer();
+        while (num > 0) {
+            int qian = num /1000;
+            int bai = num % 1000;
+        }
+        return stringBuffer.toString();
+    }
+
+    /**
+     * 相同，并且有下标不大于k；
+     * 判断数组中是否存在两个不同的索引 i 和 j
+     *
+     * @param nums
+     * @param k
+     * @return
+     */
+    public boolean containsNearbyDuplicate(int[] nums, int k) {
+        Map<Integer, LinkedList<Integer>> indexMap = new HashMap<>();
+        int gap = Integer.MAX_VALUE;
+        for (int i = 0; i < nums.length; i++) {
+            int num = nums[i];
+            LinkedList<Integer> indexMapOrDefault = indexMap.getOrDefault(num, new LinkedList<>());
+            if (indexMapOrDefault.size() >= 1) {
+                gap = Math.min(i - indexMapOrDefault.get(indexMapOrDefault.size()-1),  gap);
+                if (gap <= k) {
+                    return true;
+                }
+            }
+            indexMapOrDefault.add(i);
+            indexMap.put(num, indexMapOrDefault);
+        }
+        return false;
+    }
+
+    public static void main(String[] args) {
+        final int test = finalTest();
+        System.out.println(test);
+
+    }
+    private static int finalTest() {
+        int temp = 1;
+        try {
+            System.out.println(temp);
+            // 首先处理temp的值，最后返回的值没有经过finally的逻辑处理的
+            return ++temp;
+        } catch (Exception e) {
+            System.out.println(temp);
+            return ++temp;
+        } finally {
+            ++temp;
+            System.out.println(temp);
+        }
+    }
+
+    @Test
+    public void mainL() {
+        int[] nums = {1,0,1,1};
+        boolean b = containsNearbyDuplicate(nums, 1);
+        log.info("{}", b);
+    }
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/tree/FirstKth.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/tree/FirstKth.java b/common/core/src/main/java/org/example/common/core/leetcode/tree/FirstKth.java
new file mode 100644
--- /dev/null	(date 1698633783450)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/tree/FirstKth.java	(date 1698633783450)
@@ -0,0 +1,211 @@
+package org.example.common.core.leetcode.tree;
+
+import lombok.extern.slf4j.Slf4j;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.PriorityQueue;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/9/14 14:01
+ */
+@Slf4j
+public class FirstKth {
+
+    @Test
+    public void main() {
+        int[] nums = {3, 2, 1, 5, 6, 4};
+        System.out.println(findKthLargest(nums, 2));
+    }
+
+    /**
+     * 用nums构造树
+     *
+     * @param nums
+     */
+    public int findKthLargest(int[] nums, int k) {
+        int heapSize = nums.length;
+        buildMaxHeap(nums, heapSize);
+        // 首先要知道的是一个大顶堆的概念。还有什么呢？
+        for (int i = nums.length - 1; i >= nums.length - k + 1; i--) {
+            swap(nums, 0, i);
+            --heapSize;
+            maxHeapify(nums, 0, heapSize);
+        }
+        return nums[0];
+    }
+
+    public void swap(int[] a, int i, int j) {
+        int temp = a[i];
+        a[i] = a[j];
+        a[j] = temp;
+    }
+
+    public void buildMaxHeap(int[] a, int heapSize) {
+        for (int i = heapSize / 2; i >= 0; --i) {
+            maxHeapify(a, i, heapSize);
+        }
+    }
+
+    public void maxHeapify(int[] a, int i, int heapSize) {
+        int l = i * 2 + 1, r = i * 2 + 2, largest = i;
+        if (l < heapSize && a[l] > a[largest]) {
+            largest = l;
+        }
+        if (r < heapSize && a[r] > a[largest]) {
+            largest = r;
+        }
+        if (largest != i) {
+            swap(a, i, largest);
+            maxHeapify(a, largest, heapSize);
+        }
+    }
+
+    public int findKthLargestI(int[] nums, int k) {
+        // 小顶堆，堆顶是最小元素
+        PriorityQueue<Integer> pq = new PriorityQueue<>();
+        for (int e : nums) {
+            // 每个元素都要过一遍二叉堆
+            pq.offer(e);
+            // 堆中元素多于 k 个时，删除堆顶元素
+            if (pq.size() > k) {
+                pq.poll();
+            }
+        }
+        // pq 中剩下的是 nums 中 k 个最大元素，
+        // 堆顶是最小的那个，即第 k 个最大元素
+        return pq.peek();
+    }
+
+    @Test
+    public void testWithApi() {
+        int[] nums = {3, 2, 1, 5, 6, 4};
+        System.out.println(findKthLargestI(nums, 2));
+    }
+
+    /**
+     * 要比较的是a(i)+b(j+1)和a(i+1)+b(j)的大小 到底是谁动呢
+     *
+     * @param nums1
+     * @param nums2
+     * @param k
+     * @return
+     */
+    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
+        List<List<Integer>> list = new ArrayList<>();
+        list.add(Arrays.asList(nums1[0], nums2[0]));
+        int i = 0, j = 0;
+        while (k > 1) {
+            while (i < nums1.length && j < nums2.length) {
+                List<Integer> integers = new ArrayList<>();
+                if (k <= 1) {
+                    break;
+                }
+                // j 更大 -->  选择j
+                if (nums1[i] + nums2[j+1] > nums1[i+1] + nums2[j]) {
+                    integers.addAll(Arrays.asList(nums1[i+1], nums2[j]));
+                    i++;
+                } else {
+                    integers.addAll(Arrays.asList(nums1[i], nums2[j+1]));
+                    j++;
+                }
+                list.add(integers);
+                k--;
+            }
+        }
+        return list;
+    }
+
+    @Test
+    public void mainKPair() {
+        int[] nums1 = {1, 7, 11};
+        int[] nums2 = {2, 4, 6};
+        List<List<Integer>> lists = kSmallestPairsSolution(nums1, nums2, 3);
+        log.info("{}", lists);
+    }
+
+    /**
+     * 用二分法？
+     *
+     * @param nums1
+     * @param nums2
+     * @param k
+     * @return
+     */
+    public List<List<Integer>> kSmallestPairsSolution(int[] nums1, int[] nums2, int k) {
+        int m = nums1.length;
+        int n = nums2.length;
+
+        /*二分查找第 k 小的数对和的大小*/
+        int left = nums1[0] + nums2[0];
+        int right = nums1[m - 1] + nums2[n - 1];
+        int pairSum = right;
+        while (left <= right) {
+            int mid = left + ((right - left) >> 1);
+            long cnt = 0;
+            int start = 0;
+            int end = n - 1;
+            while (start < m && end >= 0) {
+                if (nums1[start] + nums2[end] > mid) {
+                    end--;
+                } else {
+                    cnt += end + 1;
+                    start++;
+                }
+            }
+            if (cnt < k) {
+                left = mid + 1;
+            } else {
+                pairSum = mid;
+                right = mid - 1;
+            }
+        }
+
+        List<List<Integer>> ans = new ArrayList<>();
+        int pos = n - 1;
+        /*找到小于目标值 pairSum 的数对*/
+        for (int i = 0; i < m; i++) {
+            while (pos >= 0 && nums1[i] + nums2[pos] >= pairSum) {
+                pos--;
+            }
+            for (int j = 0; j <= pos && k > 0; j++, k--) {
+                List<Integer> list = new ArrayList<>();
+                list.add(nums1[i]);
+                list.add(nums2[j]);
+                ans.add(list);
+            }
+        }
+
+        /*找到等于目标值 pairSum 的数对*/
+        pos = n - 1;
+        for (int i = 0; i < m && k > 0; i++) {
+            int start1 = i;
+            while (i < m - 1 && nums1[i] == nums1[i + 1]) {
+                i++;
+            }
+            while (pos >= 0 && nums1[i] + nums2[pos] > pairSum) {
+                pos--;
+            }
+            int start2 = pos;
+            while (pos > 0 && nums2[pos] == nums2[pos - 1]) {
+                pos--;
+            }
+            if (nums1[i] + nums2[pos] != pairSum) {
+                continue;
+            }
+            int count = (int) Math.min(k, (long) (i - start1 + 1) * (start2 - pos + 1));
+            for (int j = 0; j < count && k > 0; j++, k--) {
+                List<Integer> list = new ArrayList<>();
+                list.add(nums1[i]);
+                list.add(nums2[pos]);
+                ans.add(list);
+            }
+        }
+        return ans;
+    }
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/dp/LongSubList.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/dp/LongSubList.java b/common/core/src/main/java/org/example/common/core/leetcode/dp/LongSubList.java
new file mode 100644
--- /dev/null	(date 1698633783400)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/dp/LongSubList.java	(date 1698633783400)
@@ -0,0 +1,107 @@
+package org.example.common.core.leetcode.dp;
+
+import java.util.Arrays;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description: 最长的公共子序列
+ * @time: 2023/9/25 14:46
+ */
+public class LongSubList {
+    /**
+     * 最长的公共子序列
+     * dp的定义是什么？ 1~m,1~n的最长
+     * int[][] dp = new int[m][n];
+     初始状态：dp[0][0] = ?
+     转移方程：dp[i][j] =
+     最后的结果
+     * @param str1
+     * @param str2
+     * @return
+     */
+    public int longestSubArr(String str1, String str2) {
+        int m = str1.length();
+        int n = str2.length();
+        int[][] dp = new int[m][n];
+        for (int i = 0; i < m; i++) {
+            for (int j = 0; j < n; j++) {
+                if (str1.charAt(i) == str2.charAt(j)) {
+                    dp[i][j] = dp[i-1][j-1] + 1;
+                }
+            }
+        }
+        return dp[m-1][n-1];
+    }
+
+    public static void main(String[] args) {
+        int dp1[] = new int[2];
+        dp1[0] = 1;
+        dp1[1] = 2;
+        System.out.println(Arrays.toString(dp1));
+    }
+
+    public int longestCommonSubsequence(String s1, String s2) {
+        int m = s1.length(), n = s2.length();
+        // 定义：s1[0..i-1] 和 s2[0..j-1] 的 lcs 长度为 dp[i][j]
+        int[][] dp = new int[m + 1][n + 1];
+        // 目标：s1[0..m-1] 和 s2[0..n-1] 的 lcs 长度，即 dp[m][n]
+        // base case: dp[0][..] = dp[..][0] = 0
+
+        for (int i = 1; i <= m; i++) {
+            for (int j = 1; j <= n; j++) {
+                // 现在 i 和 j 从 1 开始，所以要减一
+                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
+                    // s1[i-1] 和 s2[j-1] 必然在 lcs 中
+                    dp[i][j] = 1 + dp[i - 1][j - 1];
+                } else {
+                    // s1[i-1] 和 s2[j-1] 至少有一个不在 lcs 中
+                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
+                }
+            }
+        }
+
+        return dp[m][n];
+    }
+
+    /**
+     * 小堆
+     */
+
+    /**
+     * 大堆
+     */
+    public void buildMaxHeap(int[] a, int heapSize) {
+        for (int i = heapSize / 2; i >= 0; --i) {
+            maxHeapify(a, i, heapSize);
+        }
+    }
+
+    /**
+     * 构建最大堆，思想是什么？
+     *
+     * @param a
+     * @param i
+     * @param heapSize
+     */
+    public void maxHeapify(int[] a, int i, int heapSize) {
+        int l = i*2+1, r = i*2+2,  largest = i;
+        if (l < heapSize && a[l] > a[largest]) {
+            largest = l;
+        }
+        if (r < heapSize && a[r] > a[largest]) {
+             largest = r;
+        }
+        if (largest != i) {
+            swap(a, i, largest);
+            maxHeapify(a, largest, heapSize);
+        }
+    }
+
+    private void swap(int[] a, int i, int j) {
+        int temp = a[i];
+        a[i] = a[j];
+        a[j] = temp;
+    }
+
+}
Index: common/web/src/main/java/org/example/web/socket/chapter03/UDPTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/web/src/main/java/org/example/web/socket/chapter03/UDPTest.java b/common/web/src/main/java/org/example/web/socket/chapter03/UDPTest.java
new file mode 100644
--- /dev/null	(date 1698633783464)
+++ b/common/web/src/main/java/org/example/web/socket/chapter03/UDPTest.java	(date 1698633783464)
@@ -0,0 +1,61 @@
+package org.example.web.socket.chapter03;
+
+import lombok.extern.slf4j.Slf4j;
+
+import java.io.IOException;
+import java.net.DatagramPacket;
+import java.net.DatagramSocket;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description: udp的单播、广播、多播
+ * @time: 2023/9/28 10:23
+ */
+@Slf4j
+public class UDPTest {
+    public static void main(String[] args) throws IOException {
+        // 开启
+        final DatagramSocket datagramSocket = new DatagramSocket(2000);
+        byte[] buf = new byte[1024];
+        final DatagramPacket receivePack = new DatagramPacket(buf, buf.length);
+        datagramSocket.receive(receivePack);
+
+        //
+        final String ip = receivePack.getAddress().getHostAddress();
+        final int port = receivePack.getPort();
+        final int length = receivePack.getLength();
+
+    }
+
+    /**
+    * udp
+     * 单播:点对点
+     * 广播：一对多
+     * 多播：组播（多组的概念）
+     *
+     * 例子1：
+     * 广播地址：
+     * 192.168.124.7
+     * mask:
+     * 255.255.255.0
+     *
+     * 网络地址：
+     * 192.168.124.0
+     * 广播地址：
+     * 192.168.124.255
+     *
+     *
+     * <p>
+     *     例子2：
+     * 广播地址：
+     * 192.168.124.7
+     * mask:
+     * 255.255.255.192
+     * 网络地址：
+     * 192.168.124.0
+     * 广播地址：
+     * 192.168.124.255
+     * </p>
+    * */
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/daily/Leet0901.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet0901.java b/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet0901.java
new file mode 100644
--- /dev/null	(date 1698633783379)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet0901.java	(date 1698633783379)
@@ -0,0 +1,31 @@
+package org.example.common.core.leetcode.daily;
+
+import org.junit.Test;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/9/1 15:59
+ */
+public class Leet0901 {
+    public int lengthOfLastWord(String s) {
+        char[] chars = s.toCharArray();
+        int len = s.length();
+        int rightBound = len-1, right = len - 1;
+        while(right >= 0) {
+            // 最后一个单词要怎么确认呢？
+            if(chars[right] == ' ') {
+                break;
+            } else {
+                right--;
+            }
+        }
+        return rightBound - right;
+    }
+
+    @Test
+    public void main() {
+        System.out.println(lengthOfLastWord("Hello World"));
+    }
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/daily/ThreadTestPriority.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/daily/ThreadTestPriority.java b/common/core/src/main/java/org/example/common/core/leetcode/daily/ThreadTestPriority.java
new file mode 100644
--- /dev/null	(date 1698633783394)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/daily/ThreadTestPriority.java	(date 1698633783394)
@@ -0,0 +1,65 @@
+package org.example.common.core.leetcode.daily;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/28 15:49
+ */
+public class ThreadTestPriority {
+    public static void main(String[] args) {
+        // 创建10个线程
+        Thread[] threads = new Thread[10];
+
+        // 创建3个高优先级线程
+        for (int i = 0; i < 3; i++) {
+            threads[i] = new HighPriorityThread(i+1);
+//            public final static int MIN_PRIORITY = 1;
+//
+//            /**
+//             * The default priority that is assigned to a thread.
+//             */
+//            public final static int NORM_PRIORITY = 5;
+//
+//            /**
+//             * The maximum priority that a thread can have.
+//             */
+//            public final static int MAX_PRIORITY = 10;
+            int val = Thread.MAX_PRIORITY;
+            threads[i].setPriority(val--);
+        }
+
+        // 创建7个普通优先级线程
+        for (int i = 3; i < 10; i++) {
+            threads[i] = new NormalPriorityThread();
+        }
+
+        // 启动线程
+        for (Thread thread : threads) {
+            thread.start();
+        }
+    }
+
+    // 高优先级线程
+    static class HighPriorityThread extends Thread {
+        int i;
+
+        public HighPriorityThread(int i) {
+            this.i = i;
+        }
+
+        @Override
+        public void run() {
+            System.out.printf("Thread %d:High priority thread is running.\n", i);
+        }
+    }
+
+    // 普通优先级线程
+    static class NormalPriorityThread extends Thread {
+        @Override
+        public void run() {
+            System.out.println("Normal priority thread is running.");
+        }
+    }
+
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1029.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1029.java b/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1029.java
new file mode 100644
--- /dev/null	(date 1698633783387)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1029.java	(date 1698633783387)
@@ -0,0 +1,79 @@
+package org.example.common.core.leetcode.daily;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/29 10:07
+ */
+public class Leet1029 {
+    // todo
+    public int hIndex(int[] citations) {
+        return 0;
+    }
+
+    /**
+     * 接雨水的问题
+     * <p>
+     *     每个位置的左右最小，
+     *     s = (min(left, right) - height[i]) * (k - j)
+     * </p>
+     *
+     * @param height
+     * @return
+     */
+    public int trap(int[] height) {
+        int len = height.length;
+        int sum = 0;
+        int leftHeight = 0, rightHeight = 0;
+        for (int i = 1; i <= len - 1; i++) {
+            /** s = (min(left, right) - height[i]) * (k - j)
+             * 什么情况是不用计算值的？
+             * A:左右边界
+             */
+            int j = 0;
+            // 会重复记录多次，不建议
+            while (j < i) {
+                // 只会记录高的
+                if (height[i] > height[j]) {
+                    leftHeight = Math.max(leftHeight, height[j]);
+                }
+                j++;
+            }
+
+
+
+        }
+
+        // 一次遍历，把所有的值给计算出来？
+        int[] leftArea = new int[len];
+        int left = height[0], right = height[len - 1];
+        leftArea[0] = left;
+        int[] rightArea =  new int[len];
+        rightArea[len - 1] = right;
+        for (int i = 1; i < len; i++) {
+            // 思想正确
+            if (height[i] > leftArea[i - 1]) {
+                leftArea[i] = height[i];
+            }
+            if (height[len - 1 - i] > rightArea[len - i]) {
+                rightArea[len - 1 - i] = 0;
+            }
+        }
+
+        // 用一个变量存储呢？
+        int L = height[0], R = height[len - 1];
+        return sum;
+    }
+
+    /**
+     * 接雨水。
+     *
+     * @param height
+     * @return
+     */
+    public int trapSolution(int[] height) {
+        return 0;
+    }
+
+}
\ No newline at end of file
Index: common/core/src/main/java/org/example/common/core/leetcode/daily/MyRun.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/daily/MyRun.java b/common/core/src/main/java/org/example/common/core/leetcode/daily/MyRun.java
new file mode 100644
--- /dev/null	(date 1698633783390)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/daily/MyRun.java	(date 1698633783390)
@@ -0,0 +1,25 @@
+package org.example.common.core.leetcode.daily;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/26 13:46
+ */
+public class MyRun implements Runnable{
+
+    @Override
+    public void run() {
+        // todo
+    }
+
+}
+
+class TestRun {
+    public static void main(String[] args) {
+//        new MyRun().start();
+        new Thread(new MyRun()).start();
+//        ThreadLocal 没有集成thread类和runnable接口。
+
+    }
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1024.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1024.java b/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1024.java
new file mode 100644
--- /dev/null	(date 1698633783383)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1024.java	(date 1698633783383)
@@ -0,0 +1,61 @@
+package org.example.common.core.leetcode.daily;
+
+import org.example.common.core.leetcode.link.ListNode;
+import org.example.common.core.leetcode.link.SumLinkList;
+import org.junit.Test;
+
+import java.nio.file.Paths;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/24 13:58
+ */
+public class Leet1024 {
+    public String simplifyPath(String path) {
+        return Paths.get(path).normalize().toString();
+    }
+
+    @Test
+    public void main() {
+        System.out.println(simplifyPath("/home/"));
+        System.out.println(simplifyPath("/../"));
+        System.out.println(simplifyPath("/home//foo/"));
+//        System.out.println(simplifyPath("/home/"));
+    }
+
+    /**
+     * 移动k步的作用是什么？
+     *
+     * @param listNode
+     * @param k
+     * @return
+     */
+    public ListNode rotateRight(ListNode listNode, int k) {
+        ListNode cur = listNode, node = null;
+        int n = 0;
+        while (cur != null) {
+            node = cur;
+            cur = cur.next;
+            n++;
+        }
+        int res = n - k % n;
+        // 首尾联起来。
+        node.next = listNode;
+        while (res > 0) {
+            node = node.next;
+            res--;
+        }
+        ListNode rotateHead = node.next;
+        node.next = null;
+        return rotateHead;
+    }
+
+    @Test
+    public void testLink() {
+        final SumLinkList sumLinkList = new SumLinkList();
+        final ListNode listNode = sumLinkList.buildLinkedList(new int[]{1, 2, 3, 4, 5});
+        System.out.println(rotateRight(listNode, 12));
+    }
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/daily/Z.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/daily/Z.java b/common/core/src/main/java/org/example/common/core/leetcode/daily/Z.java
new file mode 100644
--- /dev/null	(date 1698633783397)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/daily/Z.java	(date 1698633783397)
@@ -0,0 +1,39 @@
+package org.example.common.core.leetcode.daily;
+
+import java.net.URL;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/18 12:15
+ */
+class X{
+    Y y=new Y();
+    public X(){
+        System.out.print("X");
+    }
+}
+class Y{
+    public Y(){
+        System.out.print("Y");
+    }
+}
+public class Z extends X{
+    Y y=new Y();
+    public Z(){
+        System.out.print("Z");
+    }
+    public static void main(String[] args) {
+        new Z();
+        final Integer a = new Integer(17);
+        final Integer b = new Integer(17);
+        System.out.println(a == b);
+
+//        URL u =new URL("http://www.123.com");
+        System.out.println("is "+ 100 + 5);
+        System.out.println(100 + 5 +" is");
+        System.out.println("is "+ (100 + 5));
+    }
+    
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/daily/TestSync.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/daily/TestSync.java b/common/core/src/main/java/org/example/common/core/leetcode/daily/TestSync.java
new file mode 100644
--- /dev/null	(date 1698633783392)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/daily/TestSync.java	(date 1698633783392)
@@ -0,0 +1,19 @@
+package org.example.common.core.leetcode.daily;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/23 14:40
+ */
+public class TestSync {
+    private synchronized void a() {
+
+    }
+
+    private void b() {
+        synchronized (this) {
+
+        }
+     }
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/daily/Test.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/daily/Test.java b/common/core/src/main/java/org/example/common/core/leetcode/daily/Test.java
new file mode 100644
--- /dev/null	(date 1698633783390)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/daily/Test.java	(date 1698633783390)
@@ -0,0 +1,47 @@
+package org.example.common.core.leetcode.daily;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/18 11:44
+ */
+class Test
+{
+    private int data;
+    int result = 0;
+    public void m()
+    {
+        result += 2;
+        data += 2;
+        System.out.print(result + "  " + data);
+    }
+}
+class ThreadExample extends Thread
+{
+    private Test mv;
+    public ThreadExample(Test mv)
+    {
+        this.mv = mv;
+    }
+    public void run()
+    {
+        synchronized(mv)
+        {
+            mv.m();
+        }
+    }
+}
+class ThreadTest
+{
+    public static void main(String args[])
+    {
+        Test mv = new Test();
+        Thread t1 = new ThreadExample(mv);
+        Thread t2 = new ThreadExample(mv);
+        Thread t3 = new ThreadExample(mv);
+        t1.start();
+        t2.start();
+        t3.start();
+    }
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/algorithm/StackToList.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/algorithm/StackToList.java b/common/core/src/main/java/org/example/common/core/leetcode/algorithm/StackToList.java
new file mode 100644
--- /dev/null	(date 1698633783371)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/algorithm/StackToList.java	(date 1698633783371)
@@ -0,0 +1,90 @@
+package org.example.common.core.leetcode.algorithm;
+
+import java.util.ArrayDeque;
+import java.util.Deque;
+import java.util.LinkedList;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description: 用2个栈实现队列
+ * a b c|| inStack
+ * c b a|| outStack
+ *
+ * @time: 2023/9/25 14:13
+ */
+public class StackToList {
+    Deque<Integer> stackIn = new LinkedList();
+    Deque<Integer> stackOut = new LinkedList();
+
+    public void push(int num) {
+        stackIn.push(num);
+        if (stackIn.size() > 1) {
+            while (!stackIn.isEmpty()) {
+                stackOut.push(stackIn.pop());
+            }
+        }
+    }
+
+    public Integer pop() {
+        //要把所有的inStack进入outStack
+        if(!stackOut.isEmpty()) {
+            return stackOut.pop();
+        }
+        return null;
+    }
+
+    public Integer peek() {
+        return stackOut.peek();
+    }
+
+    public boolean empty() {
+        return stackOut.isEmpty();
+    }
+
+    public static void main(String[] args) {
+        final MyQueue stackToList = new MyQueue();        stackToList.push(1);
+        stackToList.push(2);
+        System.out.println(stackToList.peek());
+        System.out.println(stackToList.pop());
+        System.out.println(stackToList.empty());
+    }
+}
+
+class MyQueue {
+    Deque<Integer> inStack;
+    Deque<Integer> outStack;
+
+    public MyQueue() {
+        inStack = new ArrayDeque<Integer>();
+        outStack = new ArrayDeque<Integer>();
+    }
+
+    public void push(int x) {
+        inStack.push(x);
+    }
+
+    public int pop() {
+        if (outStack.isEmpty()) {
+            in2out();
+        }
+        return outStack.pop();
+    }
+
+    public int peek() {
+        if (outStack.isEmpty()) {
+            in2out();
+        }
+        return outStack.peek();
+    }
+
+    public boolean empty() {
+        return inStack.isEmpty() && outStack.isEmpty();
+    }
+
+    private void in2out() {
+        while (!inStack.isEmpty()) {
+            outStack.push(inStack.pop());
+        }
+    }
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/algorithm/MidAlg.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/algorithm/MidAlg.java b/common/core/src/main/java/org/example/common/core/leetcode/algorithm/MidAlg.java
new file mode 100644
--- /dev/null	(date 1698633783369)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/algorithm/MidAlg.java	(date 1698633783369)
@@ -0,0 +1,129 @@
+package org.example.common.core.leetcode.algorithm;
+
+import lombok.extern.slf4j.Slf4j;
+import org.junit.Test;
+
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/8/30 9:36
+ */
+@Slf4j
+public class MidAlg {
+    /**
+     * 寻找目标的位置。
+     *
+     * @param matrix
+     * @param target
+     * @return
+     */
+    public boolean searchMatrix(int[][] matrix, int target) {
+        if (matrix == null) {
+            return false;
+        }
+        int m = matrix.length;
+        int n = matrix[0].length;
+        int[] ints = new int[m * n];
+        for (int i = 0; i < m; i++) {
+            // 对数组的复制。
+        }
+        return false;
+    }
+
+    public boolean findTargetByMidSearch(int[] arr, int target, int left, int right) {
+
+        while(left <= right) {
+            int mid = left + (right - left)/2;
+            if (arr[mid] > target) {
+                right = mid-1;
+            } else if (arr[mid] == target) {
+                return true;
+            } else {
+                left = mid+1;
+            }
+        }
+        findTargetByMidSearch(arr, target, left, right);
+        findTargetByMidSearch(arr, target, left, right);
+        return false;
+    }
+
+    @Test
+    public void main() {
+        int[] matrix = {1,3,4, 10,11,20, 33,34,60};
+        System.out.println(findTargetByMidSearch(matrix, 3, 0, matrix.length - 1));
+    }
+
+    public int binarySearchFirstColumn(int[][] matrix, int target) {
+        int len = matrix.length;
+        int left = 0;
+        while (left <= len -1) {
+            int mid = (left + len) / 2;
+            if (matrix[mid][0] <= target) {
+                left = mid;
+            } else {
+                len = mid - 1;
+            }
+        }
+        return left;
+    }
+
+    /**
+     * 螺旋输出所有的数据。
+     *
+     * @param matrix
+     * @return
+     */
+    public List<Integer> spiralOrder(int[][] matrix) {
+        int left = 0, right = matrix[0].length-1,
+        bottom = matrix.length-1, upper = 0;
+
+        List<Integer> list = new LinkedList<>();
+        if (matrix == null) {
+            return null;
+        }
+        while (true) {
+            // left --> right
+            for (int i = left; i <= right; i++) {
+                list.add(matrix[upper][i]);
+            }
+            // 下一个步骤
+            if (++upper > bottom) {
+                break;
+            }
+            // upper --> bottom
+            for (int i = upper; i <= bottom; i++) {
+                list.add(matrix[i][right]);
+            }
+            if (left > --right) {
+                break;
+            }
+            // right --> left
+            for (int i = right; i >= left; i--) {
+                list.add(matrix[bottom][i]);
+            }
+            if (upper > --bottom) {
+                break;
+            }
+            // bottom --> upper
+            for (int i = bottom; i >= upper; i--) {
+                list.add(matrix[i][left]);
+            }
+            if (++left > right) {
+                break;
+            }
+        }
+        return list;
+    }
+
+    @Test
+    public void sout() {
+        int[][] matrix = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};
+        List<Integer> integers = spiralOrder(matrix);
+        log.info("{}", integers);
+    }
+
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/algorithm/ZhaoShang.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/algorithm/ZhaoShang.java b/common/core/src/main/java/org/example/common/core/leetcode/algorithm/ZhaoShang.java
new file mode 100644
--- /dev/null	(date 1698993122538)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/algorithm/ZhaoShang.java	(date 1698993122538)
@@ -0,0 +1,229 @@
+package org.example.common.core.leetcode.algorithm;
+
+import lombok.extern.slf4j.Slf4j;
+import lombok.val;
+import org.junit.Test;
+
+import java.util.*;
+import java.util.stream.Collectors;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/9/10 16:25
+ */
+@Slf4j
+public class ZhaoShang {
+
+    public ArrayList<String> timeSort (ArrayList<String> times) {
+        List<String> collect = times.stream().sorted(((Comparator<String>) (o1, o2) -> Integer.parseInt(o1.split(":")[2]) - Integer.parseInt(o2.split(":")[2]))
+                        .thenComparing(o->Integer.parseInt(o.split(":")[1]))
+                        .thenComparing(o->Integer.parseInt(o.split(":")[0])))
+                .collect(Collectors.toCollection(LinkedList::new));
+        ArrayList<String> res = new ArrayList<>(collect);
+        return res;
+    }
+
+    @Test
+    public void main() {
+        ArrayList<String> strings = new ArrayList<String>();
+        strings.add("12:30:10");
+        strings.add( "12:15:12");
+        strings.add("15:20:14");
+        System.out.println(timeSort(strings));
+    }
+
+    public String maxDictionaryOrder (String s) {
+        // write code here
+        int[] china = new int[26];
+        Map<Character, Integer> indexMap = new HashMap<>();
+        StringBuffer stringBuffer = new StringBuffer(s).reverse();
+        // 初始化最大的字符。
+        for (int i = 0; i < s.length(); i++) {
+            char c = s.charAt(i);
+            china[c - 'a']++;
+            indexMap.put(c, Math.max(indexMap.getOrDefault(c, 0), i));
+        }
+        StringBuilder res = new StringBuilder();
+        int pre = Integer.MIN_VALUE;
+        for (int i = 25; i >= 0; i--) {
+            // 还有一个约束，下标一定要符合要求。
+            if (china[i] > 0) {
+                char temp = (char)(i + 'a');
+                Integer localIndex = indexMap.get(temp);
+                if (Integer.MIN_VALUE == pre) {
+                    pre = localIndex;
+                } else {
+                    pre = indexMap.get(res.charAt(res.length()-1));
+                }
+                // 初始化 第一个不为0的值 后续要进行一个更新
+
+                // 比较值
+                if (localIndex < pre) {
+                    continue;
+                }
+
+                // 什么情况是要比较的呢?
+                if (china[i] + localIndex > s.length()) {
+                    for (int j = 0; j < s.length() - localIndex; j++) {
+                        res.append(temp);
+                    }
+                } else {
+                    for (int j = 0; j < china[i]; j++) {
+                        res.append(temp);
+                    }
+                }
+            }
+        }
+        return res.toString();
+    }
+
+    public String maxDictionarySubStrOrder(String s) {
+        String result = null;
+        StringBuilder resultBuilder = new StringBuilder();
+        if (s == null || s == "") {
+            return result;
+        }
+        char[] arr = s.toCharArray();
+        int maxIndex = 0;
+        //一次for循环找到当前最大的char，循环一次则子串要从当前最大串往后找
+        //如abcacacabaaaba，一次循环c最大,下标为2，则第二次循环从c后开始,下标为3，找到最大值c，下标为4
+        for (int i = maxIndex; i < arr.length; i++) {
+            //最大值初始化为子串首字母
+            char max = arr[i];
+            //下次for循环从最大char往后找
+            //每次循环完了要把最大值的index往后挪
+            maxIndex = i;
+            for (int j = i; j < arr.length; j++) {
+                if (arr[j] > max) {
+                    max = arr[j];
+                    maxIndex = j;
+                }
+            }
+            //要修改i的值，即改变外层循环
+            i = maxIndex;
+            resultBuilder.append(max);
+        }
+
+        result = resultBuilder.toString();
+        return result;
+    }
+
+    /**
+     * <h1>数字进行字典排序，求第k个的数据</h1>
+     * <p>
+     *   给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。
+     * </p>
+     *
+     * @param n
+     * @param k
+     * @return m
+     */
+    public int findKthNumber(int n, int k) {
+        int ans = 1;
+        while (k > 1) {
+            int cnt = getSteps(ans, n);
+            // cnt的意思为？
+            if (cnt < k) {
+                k -= cnt;
+                ans++;
+            } else {
+                k--;
+                ans *= 10;
+            }
+        }
+        return ans;
+    }
+    public int getSteps(int curr, long n) {
+        int steps = 0;
+        long first = curr;
+        long last = curr;
+        while (first <= n) {
+            steps += Math.min(last, n) - first + 1;
+            first = first * 10;
+            last = last * 10 + 9;
+        }
+        return steps;
+    }
+
+    /**
+     * 这个的for循环的意思在哪里？
+     *
+     * @param n
+     * @return
+     */
+    public List<Integer> lexicalOrder(int n) {
+        List<Integer> ret = new ArrayList<Integer>();
+        int number = 1;
+        for (int i = 0; i < n; i++) {
+            ret.add(number);
+            if (number * 10 <= n) {
+                number *= 10;
+            } else {
+                while (number % 10 == 9 || number + 1 > n) {
+                    number /= 10;
+                }
+                number++;
+            }
+        }
+        return ret;
+    }
+
+    @Test
+    public void kthTest() {
+        final ArrayList<Integer> list = new ArrayList<>();
+        val list1 = findKthNumber(13, 5);
+        log.info("{}", list1);
+    }
+
+    public boolean canJump(int[] nums) {
+        int n = nums.length;
+        int farthest = 0;
+        for (int i = 0; i < n - 1; i++) {
+            // 不断计算能跳到的最远距离
+            farthest = Math.max(farthest, i + nums[i]);
+            // 可能碰到了 0，卡住跳不动了
+            if (farthest <= i) {
+                return false;
+            }
+        }
+        return farthest >= n - 1;
+    }
+
+    @Test
+    public void  testJump() {
+        int[] nums = {3,2,1,0,4};
+        System.out.println(canJump(nums));
+    }
+
+    public List<String> generateParenthesis(int n) {
+        if(n == 0){
+            return new ArrayList();
+        }
+        List<String> list = new ArrayList<>();
+        dfs(n, n, list, "");
+        return list;
+    }
+
+    public void dfs(int left, int right, List<String> list, String s) {
+        if (left < 0 || right < 0) {
+            return;
+        }
+        if(left == 0 && right == 0) {
+            list.add(s);
+        }
+        if(left > right) {
+            return;
+        }
+        dfs(left - 1, right, list, s+"(");
+        dfs(left, right - 1, list, s+")");
+    }
+
+    @Test
+    public void testPa() {
+        System.out.println(generateParenthesis(3));
+    }
+
+
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/dfs/Solution.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.example.common.core.leetcode.dfs;\r\n\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.junit.Test;\r\n\r\nimport java.util.*;\r\n\r\n/**\r\n * @Author: lejun\r\n * @project: cloud\r\n * @description:\r\n * @time: 2023/8/24 16:26\r\n */\r\n@Slf4j\r\npublic class Solution {\r\n    /**\r\n     * 生成括号对！\r\n     *\r\n     * @param n\r\n     * @return\r\n     */\r\n    public List<String> generateParenthesis(int n) {\r\n        StringBuffer stringBuffer = new StringBuffer();\r\n        int left = n, right = n;\r\n        List<String> list = new ArrayList<>();\r\n        generateDfs(\"\", n, n, list);\r\n        return list;\r\n    }\r\n\r\n    public void generateDfs(String s, int left, int right, List<String> list) {\r\n        if (left == 0 && right == 0) {\r\n            list.add(s);\r\n            return;\r\n        }\r\n        if(right < left) {\r\n             return;\r\n        }\r\n        if (left > 0) {\r\n            generateDfs(s+\"(\", left - 1, right, list);\r\n        }\r\n        if (right > left && right > 0) {\r\n            generateDfs(s+\")\", left, right-1, list);\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void main() {\r\n        System.out.println(generateParenthesis(3));\r\n    }\r\n\r\n    /**\r\n     * -2: 表示了 (-1,0)\r\n     * -1:表示了（1,0）\r\n     * 1<=x<=9表示了向前走动了多少。\r\n     * 障碍物的作用是有：在移动的前一个位置。\r\n     * <p>\r\n     *     右：就是（x-1， y）\r\n     *     左：（x+1，y）\r\n     *     上:(x,y-1)\r\n     * </p>\r\n     * @param commands\r\n     * @param obstacles\r\n     * @return\r\n     */\r\n    public int robotSim(int[] commands, int[][] obstacles) {\r\n        if (commands == null) {\r\n            return 0;\r\n        }\r\n        int x = 0, y = 0;\r\n\r\n        for (int i = 0; i < commands.length; i++) {\r\n            // 判断出方向；\r\n            if (commands[i] > 0) {\r\n                y += commands[i];\r\n            } else if (commands[i] == -1) {\r\n                x += commands[i];\r\n            } else {\r\n                x -= commands[i];\r\n            }\r\n\r\n        }\r\n        return uDist(x, y);\r\n    }\r\n\r\n    public int uDist(int x, int y) {\r\n        return (int) (Math.pow(x, 2) + Math.pow(y, 2));\r\n    }\r\n\r\n    public int[] returnPosition(int x, int y, int[][] grid, int direction) {\r\n        int[] res = new int[2];\r\n        int[] obstacle = Arrays.stream(grid)\r\n                .filter(item -> item[0] == x || item[1] == y).findAny()\r\n                .get();\r\n        String dir = getDirection(direction);\r\n        if (\"LEFT\".equals(dir)) {\r\n            res[0] = x+1;\r\n            res[1] = y;\r\n        } else if (\"RIGHT\".equals(dir)) {\r\n            res[0] = x-1;\r\n            res[1] = y;\r\n        } else {\r\n            res[0] = x;\r\n            res[1]= y-1;\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    public String getDirection(int dir) {\r\n        String diretion;\r\n        switch (dir) {\r\n            case -2:\r\n                diretion = \"LEFT\";\r\n                break;\r\n            case -1:\r\n                diretion = \"RIGHT\";\r\n                break;\r\n            default:\r\n                diretion = \"UPPER\";\r\n                break;\r\n        }\r\n        return diretion;\r\n    }\r\n\r\n    public int robotsSimSolution(int[] commands, int[][] obstacles) {\r\n        int[][] dirs = {{-1,0}, {0, 1}, {1,0}, {0, -1}};\r\n        int  px = 0, py = 0, d = 1;\r\n        Set<Integer> set = new HashSet<>();\r\n        for (int[] obstacle : obstacles) {\r\n            set.add(obstacle[0] * 60001 + obstacle[1]);\r\n        }\r\n\r\n        int res = 0;\r\n        for (int command : commands) {\r\n            if (command < 0) {\r\n                //                 right    down   left    upper\r\n                // int[][] dirs = {{-1,0}, {0, 1}, {1,0}, {0, -1}};\r\n                d += command == -1 ? 1 :-1;\r\n                d %= 4;\r\n                if (d < 0) {\r\n                    d += 4;\r\n                }\r\n            } else {\r\n                // 一步一步的走。要是有障碍物就处理。\r\n                for (int i = 0; i < command; i++) {\r\n                    if (set.contains(px +  dirs[d][0] *  60001 + py + dirs[d][1])) {\r\n                        break;\r\n                    }\r\n                    px += dirs[d][0];\r\n                    py += dirs[d][1];\r\n                    res = Math.max(res, px*px + py*py);\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    @Test\r\n    public void obs() {\r\n        int[] commands = {4,-1,4,-2,4};\r\n        int[][] obstacles = {{2,4}};\r\n        int i = robotsSimSolution(commands, obstacles);\r\n        log.info(\"{}\", i);\r\n    }\r\n\r\n    //记录下所有的移动路径数据\r\n    public List<List<Integer>> pathWithObstacles(int[][] obstacleGrid) {\r\n        List<List<Integer>> res = new ArrayList<>();\r\n        if (obstacleGrid[obstacleGrid.length - 1][obstacleGrid[0].length - 1] == 1) {\r\n            return res;\r\n        }\r\n        dfs(obstacleGrid, 0, 0, res);\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * 一直想要的方法。获取到所有的路径。\r\n     *\r\n     * @param grid\r\n     * @param r\r\n     * @param c\r\n     * @param res\r\n     * @return\r\n     */\r\n    private boolean dfs(int[][] grid, int r, int c, List<List<Integer>> res) {\r\n        if (r == grid.length || c == grid[0].length || grid[r][c] == 1) {\r\n            return false;\r\n        }\r\n        if (r == grid.length - 1 && c == grid[0].length - 1) {\r\n            res.add(Arrays.asList(grid.length - 1, grid[0].length - 1));\r\n            return true;\r\n        }\r\n        res.add(Arrays.asList(r,c));\r\n        if (dfs(grid, r + 1, c, res)) {\r\n            return true;\r\n        }\r\n        if (dfs(grid, r, c+1, res)) {\r\n            return true;\r\n        }\r\n        grid[r][c] = 1;\r\n        res.remove(res.size() - 1);\r\n        return false;\r\n    }\r\n\r\n    // 回溯。获取到所有的全排列\r\n    public List<List<Integer>> permute(int[] nums) {\r\n        if (nums == null) {\r\n            return new ArrayList<>();\r\n        }\r\n        List<List<Integer>> res = new ArrayList<>();\r\n        boolean[] flag = new boolean[nums.length];\r\n        Arrays.fill(flag, false);\r\n        List<Integer> path = new ArrayList<>();\r\n        dfsNum(nums, nums.length, 0, path, res, flag);\r\n        return res;\r\n    }\r\n\r\n    private void dfsNum(int[] nums, int len, int depth, List<Integer> path,\r\n                        List<List<Integer>> res, boolean[] flag) {\r\n        if (depth == len) {\r\n            res.add(path);\r\n            return;\r\n        }\r\n        for (int i = 0; i < len; i++) {\r\n            if (!flag[i]) {\r\n                ArrayList<Integer> newPath = new ArrayList<>(path);\r\n                newPath.add(nums[i]);\r\n\r\n                boolean[] newUsed = new boolean[len];\r\n                System.arraycopy(flag, 0, newUsed, 0, len);\r\n                newUsed[i] = true;\r\n\r\n                dfsNum(nums, len, depth + 1, newPath, res, newUsed);\r\n            }\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void genNums() {\r\n        System.out.println(permute(new int[]{1, 2, 3}));\r\n    }\r\n\r\n    /**\r\n     * [1,1,2] ==》\r\n     * <p>\r\n     *  [[1,1,2],\r\n     *  [1,2,1],\r\n     *  [2,1,1]]\r\n     * </p>\r\n     *\r\n     * @param nums\r\n     * @return\r\n     */\r\n    List<List<Integer>> res = new LinkedList<>();\r\n    LinkedList<Integer> track = new LinkedList<>();\r\n\r\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\r\n        // 先排序，让相同的元素靠在一起\r\n        Arrays.sort(nums);\r\n        backtrack(nums, 0);\r\n        return res;\r\n    }\r\n\r\n    void backtrack(int[] nums, int start) {\r\n        // 前序位置，每个节点的值都是一个子集\r\n        res.add(new LinkedList<>(track));\r\n\r\n        for (int i = start; i < nums.length; i++) {\r\n            // 剪枝逻辑，值相同的相邻树枝，只遍历第一条\r\n            if (i > start && nums[i] == nums[i - 1]) {\r\n                continue;\r\n            }\r\n            track.addLast(nums[i]);\r\n            backtrack(nums, i + 1);\r\n            track.removeLast();\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void test() {\r\n        System.out.println(subsetsWithDup(new int[]{1, 1, 2}));\r\n    }\r\n\r\n    /**\r\n     * 判断数独的有效性\r\n     * 1.数字 1-9 在每一行只能出现一次。\r\n     * 2.数字 1-9 在每一列只能出现一次。\r\n     * 3.数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）\r\n     * @param board\r\n     * @return\r\n     */\r\n    public boolean isValidSudo(char[][] board) {\r\n        int[][] rows = new int[9][9];\r\n        int[][] cols = new int[9][9];\r\n        int[][][] subboxes = new int[ 3][3][9];\r\n        for (int i = 0; i < 9; i++) {\r\n            for (int j = 0; j < 9; j++) {\r\n                char c = board[i][j];\r\n                if (c != '.') {\r\n                    int index = c - '0' - 1;\r\n                    rows[i][index]++;\r\n                    cols[j][index]++;\r\n                    subboxes[i/3][j/3][index]++;\r\n                    if (rows[i][index] > 1 || cols[j][index] > 1 ||\r\n                            subboxes[i][j][index] > 1) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    public boolean isValidSudoku(char[][] board) {\r\n        int m = board.length;\r\n        int n = board[0].length;\r\n        // 要动态的表示出啊\r\n        int[][][] subBox = new int[3][3][9];\r\n        // rows\r\n        int[][] rows = new int[9][9];\r\n        // cols\r\n        int[][] cols = new int[9][9];\r\n        for (int i = 0; i < m; i++) {\r\n            for (int j = 0; j < n; j++) {\r\n                char c = board[i][j];\r\n                if (c != '.') {\r\n                    int index = c - '0';\r\n                    rows[i][index]++;\r\n                    cols[j][index]++;\r\n                    subBox[i/3][j/3][index]++;\r\n                    // 不能有多个的意思！\r\n                    if (rows[i][index] > 1 || cols[j][index] > 1 ||\r\n                            subBox[i][j][index] > 1) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean canConstruct(String ransomNote, String magazine) {\r\n        if(magazine == null || magazine.length() == 0||\r\n                ransomNote == null || ransomNote.length() == 0) {\r\n            return false;\r\n        }\r\n        Map<Character, Integer> map = new HashMap();\r\n        for (char c : magazine.toCharArray()) {\r\n            map.put(c, map.getOrDefault(c, 0) + 1);\r\n        }\r\n\r\n        for (char c : ransomNote.toCharArray()) {\r\n            if (!map.containsKey(c)) {\r\n                return false;\r\n            }\r\n\r\n            int value = map.get(c) - 1;\r\n            if (value < 0) {\r\n                return false;\r\n            }\r\n            map.put(c, value);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int[][] insert(int[][] intervals, int[] newIntervals) {\r\n        int n = intervals.length;\r\n        int[][] newInts = new int[n+1][2];\r\n        int index = 0, i = 0;\r\n        while (i < n && intervals[i][1] < newIntervals[0]) {\r\n            newInts[index++] = intervals[i++];\r\n        }\r\n        // 比较\r\n        while (i < n && intervals[i][0] <= newIntervals[1]) {\r\n            newIntervals[0] = Math.min(intervals[i][0], newIntervals[0]);\r\n            newIntervals[1] = Math.min(intervals[i][1], newIntervals[1]);\r\n            i++;\r\n        }\r\n        newInts[index++] = newIntervals;\r\n        // 结尾\r\n        while (i < n) {\r\n            newInts[index++] = intervals[i++];\r\n        }\r\n        return Arrays.copyOf(newInts, index);\r\n    }\r\n\r\n    /**\r\n     * 最少的箭引爆所有的气球区间\r\n     * <p>\r\n     *     有的是什么呢？就是说有a[1] < b[0]的时候，就有箭的数量加一了。\r\n     * </p>\r\n     *\r\n     * @param points\r\n     * @return\r\n     */\r\n    public int findMinArrowShots(int[][] points) {\r\n        Arrays.sort(points, (Comparator.comparingInt(o -> o[1])));\r\n        int cnt = 1;\r\n        int n = points.length;\r\n        int end = points[0][1];\r\n        for (int i = 0; i < n; i++) {\r\n            int start = points[i][0];\r\n            if (start > end) {\r\n                end = points[i][1];\r\n                cnt++;\r\n            }\r\n        }\r\n        return cnt;\r\n    }\r\n\r\n    @Test\r\n    public void minShoot() {\r\n//        int[][] point = [[10,16],[2,8],[1,6],[7,12]];\r\n        \r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/dfs/Solution.java b/common/core/src/main/java/org/example/common/core/leetcode/dfs/Solution.java
--- a/common/core/src/main/java/org/example/common/core/leetcode/dfs/Solution.java	(revision cf8ea38fa9da362ec8a79646980a64be2e30bae6)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/dfs/Solution.java	(date 1698633783399)
@@ -222,6 +222,7 @@
             return;
         }
         for (int i = 0; i < len; i++) {
+            // 只要是没有使用过的就可以添加进入逻辑处理。
             if (!flag[i]) {
                 ArrayList<Integer> newPath = new ArrayList<>(path);
                 newPath.add(nums[i]);
@@ -261,6 +262,12 @@
         return res;
     }
 
+    /**
+     * 相同数字的时候，会有不能选择的，但不同的数字是无所谓的。
+     *
+     * @param nums
+     * @param start
+     */
     void backtrack(int[] nums, int start) {
         // 前序位置，每个节点的值都是一个子集
         res.add(new LinkedList<>(track));
Index: common/core/src/main/java/org/example/common/core/leetcode/daily/Leet0902.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet0902.java b/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet0902.java
new file mode 100644
--- /dev/null	(date 1698633783381)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet0902.java	(date 1698633783381)
@@ -0,0 +1,61 @@
+package org.example.common.core.leetcode.daily;
+
+import lombok.extern.slf4j.Slf4j;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/9/2 21:46
+ */
+@Slf4j
+public class Leet0902 {
+    public List<String> summaryRanges(int[] nums) {
+        List<String> list = new ArrayList<>();
+        StringBuffer stringBuffer = new StringBuffer();
+        int pointer = 0;
+        while (pointer < nums.length) {
+            int left = pointer;
+            while (pointer + 1 < nums.length && nums[pointer] + 1 == nums[pointer+1]) {
+                pointer++;
+            }
+            if (pointer > left) {
+                stringBuffer.append(nums[left])
+                        .append("->")
+                        .append(nums[pointer]);
+                list.add(stringBuffer.toString());
+                stringBuffer.setLength(0);
+            } else {
+                list.add(nums[left]+"");
+            }
+            pointer++;
+        }
+        return list;
+    }
+
+    @Test
+    public void main() {
+        int[] nums = {0,1,2,4,5,7};
+        List<String> strings = summaryRanges(nums);
+        log.info("{}", strings);
+    }
+
+    @Test
+    public void test() {
+        int i = 5;
+        int j = 10;
+        // 1010  -n=~n+1可推出~n=-n-1，所以~10=-11再加5结果为-6
+        log.info("{}", ~j);
+        System.out.println(i + ~j);
+
+        String abc = "abc";
+        String abc2= "a" + new String("bc");
+        System.out.println(abc==abc2);
+    }
+
+
+}
Index: common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1028.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1028.java b/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1028.java
new file mode 100644
--- /dev/null	(date 1698633783385)
+++ b/common/core/src/main/java/org/example/common/core/leetcode/daily/Leet1028.java	(date 1698633783385)
@@ -0,0 +1,67 @@
+package org.example.common.core.leetcode.daily;
+
+import java.util.Arrays;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/28 15:14
+ */
+public class Leet1028 {
+    /**
+     * <p>
+     *    思想是没有错的，但是没有考虑到的是board - max【i】
+     * </p>
+     *
+     * @param h
+     * @param w
+     * @param horizontalCuts
+     * @param verticalCuts
+     * @return
+     */
+    public int maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts) {
+        // 需要对所有的蛋糕进行一个切割处理。
+        int mod = (int) (1e9 + 7);
+        int validH = horizontalCuts.length - 1;
+        int validV = verticalCuts.length - 1;
+        for (int i = 0; i < horizontalCuts.length; i++) {
+            if (horizontalCuts[i] > h) {
+                validH = i;
+            }
+        }
+        for (int i = 0; i < verticalCuts.length; i++) {
+            if (verticalCuts[i] > h) {
+                validV = i;
+            }
+        }
+        // 因为切割是只和上一个切割的位置有关，所有。他是一个dp处理？
+        int max = Integer.MIN_VALUE;
+        //计算出前缀和，比较数据
+        int[] preSumH = new int[validH - 1];
+        int[] preSumV = new int[validV - 1];
+        for (int i = 0; i < validH; i++) {
+            preSumH[i] = horizontalCuts[i + 1] - horizontalCuts[i];
+        }
+        for (int i = 0; i < validV; i++) {
+            preSumV[i] = verticalCuts[i + 1] - verticalCuts[i];
+        }
+        // 1 3 5   2 2; 1 2 4  1 2
+        return  max;
+    }
+
+    public int maxAreaSolution(int h, int w, int[] horizontalCuts, int[] verticalCuts) {
+        Arrays.sort(horizontalCuts);
+        Arrays.sort(verticalCuts);
+        return (int) ((long) calMax(horizontalCuts, h) * calMax(verticalCuts, w) % 1000000007);
+    }
+
+    public int calMax(int[] arr, int boardr) {
+        int res = 0, pre = 0;
+        for (int i : arr) {
+            res = Math.max(i - pre, res);
+            pre = i;
+        }
+        return Math.max(res, boardr - pre);
+    }
+}
Index: common/web/src/main/java/org/example/web/socket/nettyTest/server/NettyServer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/web/src/main/java/org/example/web/socket/nettyTest/server/NettyServer.java b/common/web/src/main/java/org/example/web/socket/nettyTest/server/NettyServer.java
new file mode 100644
--- /dev/null	(date 1699085815017)
+++ b/common/web/src/main/java/org/example/web/socket/nettyTest/server/NettyServer.java	(date 1699085815017)
@@ -0,0 +1,53 @@
+package org.example.web.socket.nettyTest.server;
+
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.nio.NioServerSocketChannel;
+import org.example.web.socket.nettyTest.config.NettyConfig;
+import org.example.web.socket.nettyTest.hanlder.TCPCountHandler;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/29 16:18
+ */
+public class NettyServer {
+    public void run(int beginPort, int endPort) {
+        System.out.println("服务端启动中。。");
+        //配置服务端线程组
+        EventLoopGroup bossGroup = new NioEventLoopGroup();
+        EventLoopGroup workGroup = new NioEventLoopGroup();
+
+        ServerBootstrap serverBootstrap = new ServerBootstrap();
+        serverBootstrap.group(bossGroup, workGroup)
+                .channel(NioServerSocketChannel.class)
+                //.childOption(ChannelOption.SO_BACKLOG, 1024)
+                .childOption(ChannelOption.TCP_NODELAY, true)
+                //快速复用端口
+                .childOption(ChannelOption.SO_REUSEADDR, true);
+
+        serverBootstrap.childHandler(new TCPCountHandler());
+
+        for (; beginPort < endPort; beginPort++) {
+            int port = beginPort;
+            serverBootstrap.bind(port).addListener((ChannelFutureListener) future -> {
+                System.out.println("服务端成功绑定端口 port = " + port);
+            });
+        }
+
+
+    }
+
+    /**
+     * 启动入口
+     *
+     * @param args
+     */
+    public static void main(String[] args) {
+        new NettyServer().run(NettyConfig.BEGIN_PORT, NettyConfig.END_PORT);
+    }
+}
Index: common/web/src/main/java/org/example/web/socket/nettyTest/ServerHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/web/src/main/java/org/example/web/socket/nettyTest/ServerHandler.java b/common/web/src/main/java/org/example/web/socket/nettyTest/ServerHandler.java
new file mode 100644
--- /dev/null	(date 1698565604382)
+++ b/common/web/src/main/java/org/example/web/socket/nettyTest/ServerHandler.java	(date 1698565604382)
@@ -0,0 +1,25 @@
+package org.example.web.socket.nettyTest;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelDuplexHandler;
+import io.netty.channel.ChannelHandlerContext;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/29 15:44
+ */
+public class ServerHandler extends ChannelDuplexHandler {
+    private int counter;
+
+    @Override
+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+        ByteBuf byteBuf = (ByteBuf) msg;
+        byte[] bytes = new byte[byteBuf.readableBytes()];
+        byteBuf.readBytes(bytes);
+        String body = new String(bytes, "UTF-8").substring(0, bytes.length - System.getProperty("line.separator").length());
+
+        System.out.println("服务端收到消息内容为：" + body + "，收到消息次数：" + ++counter);
+    }
+}
Index: common/web/src/main/java/org/example/web/socket/nettyTest/HalfPacketTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/web/src/main/java/org/example/web/socket/nettyTest/HalfPacketTest.java b/common/web/src/main/java/org/example/web/socket/nettyTest/HalfPacketTest.java
new file mode 100644
--- /dev/null	(date 1698567485069)
+++ b/common/web/src/main/java/org/example/web/socket/nettyTest/HalfPacketTest.java	(date 1698567485069)
@@ -0,0 +1,32 @@
+package org.example.web.socket.nettyTest;
+
+import io.netty.bootstrap.ServerBootstrap;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/29 15:43
+ */
+public class HalfPacketTest {
+    public static void main(String[] args) {
+//        final EventLoopGroup bossGroup = new EventLoopGroup();
+        //创建启动引导类
+        ServerBootstrap serverBootstrap = new ServerBootstrap();
+        //加入服务端线程组 todo 这两个要怎么创建。
+//        serverBootstrap.group(bossGroup,workGroup)
+//                //设置管道
+//                .channel(NioServerSocketChannel.class)
+//                .option(ChannelOption.SO_BACKLOG,1024)
+//                //加入处理器
+//                .childHandler(new ChannelInitializer<SocketChannel>() {
+//                    @Override
+//                    protected void initChannel(SocketChannel socketChannel) throws Exception {
+//                        //加入处理器ServerHandler
+//                        socketChannel.pipeline().addLast(new ServerHandler());
+//                    }
+//                });
+
+        System.out.println("Echo服务启动中...");
+    }
+}
Index: common/web/src/main/java/org/example/web/socket/nettyTest/ToIntegerDecoder.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/web/src/main/java/org/example/web/socket/nettyTest/ToIntegerDecoder.java b/common/web/src/main/java/org/example/web/socket/nettyTest/ToIntegerDecoder.java
new file mode 100644
--- /dev/null	(date 1698564501805)
+++ b/common/web/src/main/java/org/example/web/socket/nettyTest/ToIntegerDecoder.java	(date 1698564501805)
@@ -0,0 +1,21 @@
+package org.example.web.socket.nettyTest;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.ReplayingDecoder;
+
+import java.util.List;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/29 15:26
+ */
+public class ToIntegerDecoder extends ReplayingDecoder<Void> {
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> out) throws Exception {
+        out.add(byteBuf.readInt());
+    }
+}
Index: common/web/src/main/java/org/example/web/socket/nettyTest/client/NettyClient.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/web/src/main/java/org/example/web/socket/nettyTest/client/NettyClient.java b/common/web/src/main/java/org/example/web/socket/nettyTest/client/NettyClient.java
new file mode 100644
--- /dev/null	(date 1698567879631)
+++ b/common/web/src/main/java/org/example/web/socket/nettyTest/client/NettyClient.java	(date 1698567879631)
@@ -0,0 +1,72 @@
+package org.example.web.socket.nettyTest.client;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.channel.socket.nio.NioSocketChannel;
+import org.example.web.socket.nettyTest.config.NettyConfig;
+
+import java.util.concurrent.ExecutionException;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/29 16:23
+ */
+public class NettyClient {
+    public void run(int beginPort, int endPort) {
+        System.out.println("客户端启动中。。");
+
+        EventLoopGroup group = new NioEventLoopGroup();
+
+        Bootstrap bootstrap = new Bootstrap();
+
+        bootstrap.group(group)
+                .channel(NioSocketChannel.class)
+                //快速复用端口
+                .option(ChannelOption.SO_REUSEADDR, true)
+                .option(ChannelOption.TCP_NODELAY, true)
+                .handler(new ChannelInitializer<SocketChannel>() {
+                    @Override
+                    protected void initChannel(SocketChannel socketChannel) throws Exception {
+
+                    }
+                });
+
+        int index = 0;
+
+        while (true) {
+            int finalPort = beginPort + index;
+            try {
+                bootstrap.connect(NettyConfig.SERVER_ADDR, finalPort).addListener((ChannelFutureListener) future -> {
+                    if (!future.isSuccess()) {
+                        System.out.println("创建连接失败 port = " + finalPort);
+                    }
+                }).get();
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            } catch (ExecutionException e) {
+                e.printStackTrace();
+            }
+            ++index;
+            if (index == (endPort - beginPort)) {
+                index = 0;
+            }
+        }
+
+    }
+
+    /**
+     * 启动入口
+     *
+     * @param args
+     */
+    public static void main(String[] args) {
+        new NettyClient().run(NettyConfig.BEGIN_PORT, NettyConfig.END_PORT);
+    }
+}
Index: common/web/src/main/java/org/example/web/socket/nettyTest/hanlder/TCPCountHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/web/src/main/java/org/example/web/socket/nettyTest/hanlder/TCPCountHandler.java b/common/web/src/main/java/org/example/web/socket/nettyTest/hanlder/TCPCountHandler.java
new file mode 100644
--- /dev/null	(date 1698567766807)
+++ b/common/web/src/main/java/org/example/web/socket/nettyTest/hanlder/TCPCountHandler.java	(date 1698567766807)
@@ -0,0 +1,45 @@
+package org.example.web.socket.nettyTest.hanlder;
+
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/29 16:20
+ */
+@ChannelHandler.Sharable
+public class TCPCountHandler extends ChannelInboundHandlerAdapter {
+
+    //使用原子类，避免线程安全问题
+    private AtomicInteger atomicInteger = new AtomicInteger();
+
+    public TCPCountHandler() {
+        Executors.newSingleThreadScheduledExecutor().scheduleAtFixedRate(() -> {
+            System.out.println("当前连接数为 = " + atomicInteger.get());
+        }, 0, 3, TimeUnit.SECONDS);
+    }
+
+    @Override
+    public void channelActive(ChannelHandlerContext ctx) throws Exception {
+        atomicInteger.incrementAndGet();
+    }
+
+    @Override
+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+        atomicInteger.decrementAndGet();
+    }
+
+    @Override
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+        System.out.println("TCPCountHandler exceptionCaught");
+        cause.printStackTrace();
+        ctx.close();
+    }
+}
Index: common/web/src/main/java/org/example/web/socket/nettyTest/config/NettyConfig.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/web/src/main/java/org/example/web/socket/nettyTest/config/NettyConfig.java b/common/web/src/main/java/org/example/web/socket/nettyTest/config/NettyConfig.java
new file mode 100644
--- /dev/null	(date 1698567633512)
+++ b/common/web/src/main/java/org/example/web/socket/nettyTest/config/NettyConfig.java	(date 1698567633512)
@@ -0,0 +1,15 @@
+package org.example.web.socket.nettyTest.config;
+
+/**
+ * @Author: lejun
+ * @project: cloud
+ * @description:
+ * @time: 2023/10/29 16:19
+ */
+public class NettyConfig {
+    public static int BEGIN_PORT = 8000;
+
+    public static int END_PORT = 8050;
+
+    public static String SERVER_ADDR = "127.0.0.1";
+}
Index: pom.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>org.example</groupId>\r\n    <artifactId>cloud</artifactId>\r\n    <version>1.0-SNAPSHOT</version>\r\n    <modules>\r\n        <module>gateway</module>\r\n        <module>stock</module>\r\n        <module>common</module>\r\n    </modules>\r\n    <packaging>pom</packaging>\r\n\r\n    <properties>\r\n        <java.version>1.8</java.version>\r\n        <spring.boot.version>2.3.3.RELEASE</spring.boot.version>\r\n        <spring.cloud.alibaba.version>2.2.6.RELEASE</spring.cloud.alibaba.version>\r\n        <spring.cloud.version>Hoxton.SR9</spring.cloud.version>\r\n        <mybatis-plus.version>3.4.3</mybatis-plus.version>\r\n        <mysql-version>8.0.17</mysql-version>\r\n        <druid-version>1.2.4</druid-version>\r\n    </properties>\r\n\r\n    <dependencies>\r\n        <!--公共的-->\r\n        <dependency>\r\n            <groupId>cn.hutool</groupId>\r\n            <artifactId>hutool-all</artifactId>\r\n            <version>5.7.22</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.projectlombok</groupId>\r\n            <artifactId>lombok</artifactId>\r\n            <version>RELEASE</version>\r\n            <scope>compile</scope>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.slf4j</groupId>\r\n            <artifactId>slf4j-log4j12</artifactId>\r\n            <version>1.7.25</version>\r\n            <scope>compile</scope>\r\n        </dependency>\r\n\r\n\r\n        <!-- https://mvnrepository.com/artifact/log4j/log4j -->\r\n        <dependency>\r\n            <groupId>log4j</groupId>\r\n            <artifactId>log4j</artifactId>\r\n            <version>1.2.17</version>\r\n        </dependency>\r\n    </dependencies>\r\n\r\n    <dependencyManagement>\r\n        <dependencies>\r\n            <dependency>\r\n                <groupId>com.baomidou</groupId>\r\n                <artifactId>mybatis-plus-boot-starter</artifactId>\r\n                <version>${mybatis-plus.version}</version>\r\n            </dependency>\r\n\r\n            <!--spring boot依赖jar-->\r\n            <dependency>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-starter-parent</artifactId>\r\n                <version>${spring.boot.version}</version>\r\n                <type>pom</type>\r\n                <scope>import</scope>\r\n            </dependency>\r\n\r\n            <!--spring cloud alibaba依赖jar-->\r\n            <dependency>\r\n                <groupId>com.alibaba.cloud</groupId>\r\n                <artifactId>spring-cloud-alibaba-dependencies</artifactId>\r\n                <version>${spring.cloud.alibaba.version}</version>\r\n                <type>pom</type>\r\n                <scope>import</scope>\r\n            </dependency>\r\n\r\n            <!--spring cloud依赖jar-->\r\n            <dependency>\r\n                <groupId>org.springframework.cloud</groupId>\r\n                <artifactId>spring-cloud-dependencies</artifactId>\r\n                <version>${spring.cloud.version}</version>\r\n                <type>pom</type>\r\n                <scope>import</scope>\r\n            </dependency>\r\n\r\n            <dependency>\r\n                <groupId>mysql</groupId>\r\n                <artifactId>mysql-connector-java</artifactId>\r\n                <version>${mysql-version}</version>\r\n            </dependency>\r\n\r\n            <dependency>\r\n                <groupId>com.alibaba</groupId>\r\n                <artifactId>druid</artifactId>\r\n                <version>${druid-version}</version>\r\n            </dependency>\r\n        </dependencies>\r\n    </dependencyManagement>\r\n\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pom.xml b/pom.xml
--- a/pom.xml	(revision cf8ea38fa9da362ec8a79646980a64be2e30bae6)
+++ b/pom.xml	(date 1698896934720)
@@ -22,6 +22,8 @@
         <mybatis-plus.version>3.4.3</mybatis-plus.version>
         <mysql-version>8.0.17</mysql-version>
         <druid-version>1.2.4</druid-version>
+        <nettty-version>4.1.55.Final</nettty-version>
+        <jol-version>0.10</jol-version>
     </properties>
 
     <dependencies>
@@ -57,6 +59,16 @@
 
     <dependencyManagement>
         <dependencies>
+            <dependency>
+                <groupId>io.netty</groupId>
+                <artifactId>netty-all</artifactId>
+                <version>${nettty-version}</version>
+            </dependency>
+            <dependency>
+                <groupId>org.openjdk.jol</groupId>
+                <artifactId>jol-core</artifactId>
+                <version>${jol-version}</version>
+            </dependency>
             <dependency>
                 <groupId>com.baomidou</groupId>
                 <artifactId>mybatis-plus-boot-starter</artifactId>
